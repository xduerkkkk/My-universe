# prim
minDIst数组用来记录每一个非最小生成树节点，与最小生成树的最近距离
```python
for _ in range(1, v + 1):
    min_val = 10002
    cur = -1
    for j in range(1, v + 1):
        if visited[j] == False and minDist[j] < min_val:
            cur = j
            min_val = minDist[j]
    visited[cur] = True
    for j in range(1, v + 1):
        if visited[j] == False and minDist[j] > graph[cur][j]:
            minDist[j] = graph[cur][j]
```

第一次遍历（初始化）：
选择1作为最小生成树的起点，minDist【1】我们初始化的时候，弄成0
下面一个for j 这个循环，检测谁能挨着1（`graph[cur][j]` 一定是小于10002）  能挨着就把mindist改了，即这个点与1的距离。
也把min_val 选出来
第二次遍历（持续迭代）：
`if visited[j] == False and minDist[j] < min_val
找一下谁刚和上一位（1）挨着呢，光挨着还不行，还要最小的mindist！ 第二次遍历的话，就是离1最近的！   把它当成最小生成树的最新一份子。
下面又是来到for j循环，检测谁挨着新份子呢，
如果可以，就去更新这些人的mindist

# Kruskal
很简单
首先，我们应该构造出edge（点1，点2，权重）这样的结构

```
定义并查集的能力
def find 查找边的归属
def union 将两个边find一下，如果不一样，就弄成一样的，意意思就是这俩个边，连一起啦

def kruskal
	根据edge的权重，从小到大排序一下
	for 循环 直接遍历所有排序好的边：
		看点一，点2，find一下，看他们是不是已经连过了
		如果没有：
			现在连。 union一下
			添加到result里
		
```
