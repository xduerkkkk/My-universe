```
for k in range(1, n+1):
        for i in range(1, n+1):
            for j in range(1, n+1):
                grid[i][j] = min(grid[i][j], grid[i][k] + grid[k][j])
```

答案取决于三大因素：**问题类型、图的特点（有无负权边）、数据范围**。

|   |   |   |   |   |
|---|---|---|---|---|
|算法|问题类型|能否处理负权边？|时间复杂度|适用场景|
|**Dijkstra**|**单源**最短路径|**不能**|O(V²) (朴素) <br> O(E log V) (堆优化)|1. 求从一个点出发到所有点的最短路。 <br> 2. **图中没有负权边**。 <br> 3. 点和边的数据范围较大（例如 V 到 10⁵）。|
|**Bellman-Ford / SPFA**|**单源**最短路径|**能**|O(V * E)|1. 求从一个点出发到所有点的最短路。 <br> 2. **图中可以有负权边**（还能判断负权环）。 <br> 3. 数据范围比 Dijkstra 要求的小一些。|
|**Floyd-Warshall**|**多源**最短路径|**能**|O(V³)|1. 求**任意两个点之间**的最短路。 <br> 2. **图中可以有负权边**（也能判断负权环）。 <br> 3. **数据范围很小**，通常顶点数 V 不会超过几百（比如 V ≤ 400），因为 V³ 增长太快了。|