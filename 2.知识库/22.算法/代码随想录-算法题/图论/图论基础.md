# 图的读取与输出
## 邻接矩阵
一般我们指的有向图：
```python
n, m = map(int, input().split())

graph = [[0] * (n + 1) for _ in range(n + 1)]

  

for _ in range(m):

    s, t = map(int, input().split())

    graph[s][t] = 1
```

cpp：

```cpp
#include <iostream> // 负责标准输入输出 (cin, cout)
#include <vector>   // 负责使用动态数组 vector

void buildGraphWithAdjMatrix() {
    int n; // 顶点数量 (Number of vertices)
    int m; // 边的数量 (Number of edges)
    
    // 从标准输入读取 n 和 m
    std::cin >> n >> m;

    
    // 1. 创建一个名为 graph 的外层 vector，它有 n + 1 个元素
    // 2. 对于这 n + 1 个元素中的每一个，都用 std::vector<int>(n + 1, 0) 来初始化。
    // 3. std::vector<int>(n + 1, 0) 的含义是：创建一个包含 n + 1 个整数的 vector，且所有值都初始化为 0。
    std::vector<std::vector<int>> graph(n + 1, std::vector<int>(n + 1, 0));

    // 循环 m 次，读取每一条边的信息
    for (int i = 0; i < m; ++i) {
        int s, t; // s: start vertex, t: terminal vertex
        std::cin >> s >> t;
        
        // C++ 的数组/vector下标访问语法与 Python 相同
        graph[s][t] = 1; // 标记从顶点 s 到顶点 t 存在一条有向边
    }
    
    // 你可以在这里添加打印或处理图的代码...
}

```

## 邻接表
```python
 n, m = map(int, input().split())

    graph = defaultdict(list)  # 邻接表
    for _ in range(m):
        s, t = map(int, input().split())
        graph[s].append(t)
```

cpp


```cpp
#include <iostream>
#include <vector>
#include <map> // 如果顶点不是连续整数，可以使用 map

void buildGraphWithAdjList() {
    int n; // 顶点数量
    int m; // 边的数量
    std::cin >> n >> m;

    // 关键指令: 申请并初始化邻接表
    // 这是一个 “vector 的 vector”，可以理解为一个数组，
    // 数组的每个位置上，都挂着一个 vector<int> (链表)
    // graph(n + 1) 的含义是：创建一个外层 vector，它有 n + 1 个元素，
    // 每个元素都是一个默认构造的、空的 std::vector<int>。
    std::vector<std::vector<int>> graph(n + 1);

    for (int i = 0; i < m; ++i) {
        int s, t;
        std::cin >> s >> t;
        
        // graph[s] 定位到代表顶点 s 的那个 vector (邻居列表)
        // .push_back(t) 是C++ vector 的标准操作，等同于 Python list 的 append()
        graph[s].push_back(t);
    }
}

```

# DFS

```
def dfs(整个图，当前节点，辅助存储答案的结构)：
	处理当前节点
	遍历该节点的邻居，
	即for neighbor in graph【node】：
		dfs（）  递归处理
```



# BFS
准备：
- 队列：前面是存放当前要扩散的节点，后面会加上未来要扩散的节点
- 与邻居矩阵一样的数组：用于标记哪些访问过了，避免重复访问
- 

```
def bfs(整个图，当前节点)：
	queue 队列，借助它实现“广度优先”
	visited 记录以及遍历过的节点

	while queue：
		将队列最左侧节点弹出，当作当前处理节点

		遍历当前节点的邻居
		即for neighbor in graph【node】
			 然后将这些邻居全部加入队列后侧

		若刚才的节点有邻居，因为while queue的缘故  会继续处理

```


```cpp
#include <vector>
#include <queue>
#include <utility> // For std::pair

class Solution {
public:
    int shortestPathBinaryMatrix(std::vector<std::vector<int>>& grid) {
        // 【前置检查】- 司令部的战前侦察
        int n = grid.size();
        // 如果起点或终点是障碍物(1)，直接宣布任务失败
        if (grid[0][0] == 1 || grid[n - 1][n - 1] == 1) {
            return -1;
        }

        // 【初始化作战单位】
        // 1. 队列：存放待处理的坐标 {row, col}
        std::queue<std::pair<int, int>> q;
        q.push({0, 0}); // 将起点(0,0)加入队列

        // 2. 标记/访问数组：在本题中，我们可以直接修改原grid来标记已访问
        // 这是一种“状态污染”技巧，可以节省空间，但要小心。
        // 将起点标记为已访问，并存储路径长度1
        grid[0][0] = 1; 

        // 3. 定义8个方向的“移动罗盘”
        int dr[] = {-1, -1, -1, 0, 0, 1, 1, 1}; // delta row
        int dc[] = {-1, 0, 1, -1, 1, -1, 0, 1}; // delta col

        // 【核心作战循环】 - BFS 主体
        while (!q.empty()) {
            // 取出当前层的队首节点
            auto [r, c] = q.front();
            q.pop();

            // 获取当前路径长度
            int distance = grid[r][c];
            
            // 【胜利条件判断】
            if (r == n - 1 && c == n - 1) {
                return distance;
            }

            // 【探索邻居】 - 对应你的Python模板 "for neighbor in ..."
            for (int i = 0; i < 8; ++i) {
                int nr = r + dr[i]; // new row
                int nc = c + dc[i]; // new column

                // 【边界与合法性检查】
                // 1. 是否在地图内 (nr >= 0 && nr < n && nc >= 0 && nc < n)
                // 2. 是否是通路 (grid[nr][nc] == 0)
                //    (因为我们把访问过的0改成了路径长度(>0)，所以grid[nr][nc] == 0 同时也判断了未访问)
                if (nr >= 0 && nr < n && nc >= 0 && nc < n && grid[nr][nc] == 0) {
                    // 将新节点加入队列
                    q.push({nr, nc});
                    // 标记为已访问，并记录路径长度
                    grid[nr][nc] = distance + 1;
                }
            }
        }

        // 【任务失败】 - 队列为空仍未到达终点
        return -1;
    }
};

```










# 797 所有可能的路径
给你一个有 `n` 个节点的 **有向无环图（DAG）**，请你找出从节点 `0` 到节点 `n-1` 的所有路径并输出（**不要求按特定顺序**）

 `graph[i]` 是一个从节点 `i` 可以访问的所有节点的列表（即从节点 `i` 到节点 `graph[i][j]`存在一条有向边）。

**示例 1：**

![](https://assets.leetcode.com/uploads/2020/09/28/all_1.jpg)

**输入：**graph = [[1,2],[3],[3],[]]
**输出：**[[0,1,3],[0,2,3]]
**解释：**有两条路径 0 -> 1 -> 3 和 0 -> 2 -> 3

## 题解
本题要记录路径
记录路径一定有回溯操作！！！

```python
def allPathsSourceTarget(self, graph: List[List[int]]) -> List[List[int]]:

        n = len(graph)

        result = []  # 存储所有路径的结果列表

        path = []   # 记录当前路径

        def dfs(node):

            # 将当前节点加入路径

            path.append(node)

            # 若到达目标节点，保存当前路径的副本

            if node == n - 1:

                result.append(path[:])

            else:

                # 遍历当前节点的所有邻居节点

                for neighbor in graph[node]:

                    dfs(neighbor)  # 递归探索邻居

            # 回溯：移除当前节点，返回上一级

            path.pop()

        # 从起点0开始DFS遍历

        dfs(0)

        return result

```
