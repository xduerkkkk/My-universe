python的数组实现是用列表，列表是可以存储不同类型的
这些对象，的地址，存储是连续的
【a, b，“1”]
a的家庭地址 下一个就是b的地址
但是！a可能在北京，b在上海，也就是实际上这俩个数据不相邻。
只有numpy.array可以实现像c那样，数据直接连续
# 二分查找
给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。

示例 1:

```
输入: nums = [-1,0,3,5,9,12], target = 9     
输出: 4       
解释: 9 出现在 nums 中并且下标为 4  
```
解法： 我们得定义区间，left，right。同时我们还要确定好，我们这个区间端点到底包含不包含target？ 区别如下
包含：```
```python
while left <= right:  

如果包含，缩小区间的过程最后有可能leftright变为同一个，比如left是1，right是2，缩小区间后l、r都是1！ 那么包含target的话，显示我们要判断这个“1”是不是target

if nums[middle] > target:
                right = middle - 1  
                
target在左区间，所以[left, middle - 1]
middle已经确定不是了，那right就没必要是middle了 
```
不包含(若左闭右开)：
```python
while left < right:  

因为left == right的时候，在[left, right)是无效的空间，所以使用 <
```
```python
if nums[middle] > target:
                right = middle 
                
target 在左区间，在[left, middle)中 right是middle没问题的。如果middle-1的话，middle-1就失效了  
```

问：为什么要写 left + (right - left) / 2？

答：在面试或者实际场景中，你不一定知道输入的数组有多长，万一数组长度达到 int 最大值，left + right 可能会发生加法溢出。当然，如果只看本题的数据范围，写 (left + right) / 2 也可以。对于 Python 来说，由于没有溢出这个概念，所以可以直接相加。

### 拓展
lower_bound是找数组第一个大于等于target的下标位置的

lower_bound的二分查找中，寻找 leftIdx 即为在数组中寻找第一个大于等于 target 的下标！
注意这里是关键
```
if nums[middle] >= target:

                right = middle - 1
```
right会把大于等于target的下标跳过去，而怎样循环结束呢？就是left跳到right的右边一个了，这个right的右边第一个就是最后的left，就是最靠近target下标的的，第一次大于等于target的下标



```python
 def lower_bound(self, nums:List[int], target: int) -> int:

        left, right = 0, len(nums) - 1

        while left <= right:

            middle = left + (right - left) // 2

            if nums[middle] >= target:

                right = middle - 1

            else:

                left  = middle + 1

        return left

    def searchRange(self, nums: List[int], target: int) -> List[int]:

        start = self.lower_bound(nums, target)

        if start == len(nums) or nums[start] != target:

            return [-1, -1]  # nums 中没有 target

        # 如果 start 存在，那么 end 必定存在

        end = self.lower_bound(nums, target + 1) - 1

        return [start, end]
```
# 移除元素
给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。

不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并**原地**修改输入数组。

元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。

示例 1: 给定 nums = [3,2,2,3], val = 3, 函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。 你不需要考虑数组中超出新长度后面的元素。

示例 2: 给定 nums = [0,1,2,2,3,0,4,2], val = 2, 函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。

快慢指针：慢指针始终待命，从下标0开始，等着快指针发号令。快指针会接触val，识别后跳过val，冲在前面找“非val”，一旦找到，告诉慢指针，找到一个非val，慢指针这时才把脚下的元素变成非val，然后往前走一步。
继续代码。相当于在同一个数组空间记录。

```python
while fast<lenth:
	if nums[fast] != val:
		nums[slow]=nums[fast]
		slow+=1
	fast+=1
return slow

```

# 997 有序数组的平方
给你一个按 **非递减顺序** 排序的整数数组 `nums`，返回 **每个数字的平方** 组成的新数组，要求也按 **非递减顺序** 排序。

如果平方后排序，那么显然时间复杂度是n（逐个平方）+nlogn（快排）

若创建个新数组，使用双指针，时间复杂度就是n
注意要点：
- while left <= right  显然，我们仍然要把等于时候的数存到新数组里
- 从大往小排，毕竟原来的left和right所处地方，就是最大数的位置。所以position是n-1，


