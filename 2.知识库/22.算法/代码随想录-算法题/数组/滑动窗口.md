# 使用条件
**如果一个问题，同时满足以下三个条件，那么它极大概率可以用滑动窗口解决：**

1. **操作对象是连续的子数组/子串。**
    
2. **求解目标是寻找一个最优（最长/最短/最大...）的子数组/子串。**
    
3. **窗口状态的判断逻辑，可以通过简单地增加一个右侧元素和删除一个左侧元素来高效更新，而无需每次都重新计算整个窗口。**
    

当你下次读到一个题目，就有意识地用这个公式去套一下：

- “最长无重复**子串**” -> 连续(√), 最优(√), 状态可高效更新(√) -> **滑动窗口！**
    
- “和为K的**子数组**” -> 连续(√), 求解个数(变种), 状态可高效更新(√) -> **滑动窗口/前缀和哈希！**
    
- “最小覆盖**子串**” -> 连续(√), 最优(√), 状态可高效更新(√) -> **滑动窗口！**
# 使用方法

- 用 `for r in ...` 循环来驱动右指针，自动扩张窗口。
* 用 `while ...` 循环来处理收缩逻辑，保证窗口在更新答案之前一定是合法的。
* 左指针 `l` 只在需要收缩时才移动。 
* 左右指针都只增不减，永不后退。
1. 扩张窗口
2. 检查条件与收缩窗口
3. 左指针向右移动，即窗口收缩
4. 更新结果




```
l,r = 0, 0

        ans = 0

        basket = defaultdict(int)

  

        for r,fruit in enumerate(fruits):

            basket[fruit] += 1

            while len(basket) > 2:

                left_fruit = fruits[l]

                basket[left_fruit] -= 1

  

                if basket[left_fruit] == 0:

                    del basket[left_fruit]

                l+=1

            ans = max(ans,r-l+1)

        return ans
```
