打家劫舍只是个设计动态规划的例子
要训练才能懂得如何写动态转移方程
# 198 打家劫舍
你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，**如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警**。

给定一个代表每个房屋存放金额的非负整数数组，计算你 **不触动警报装置的情况下** ，一夜之内能够偷窃到的最高金额。

**示例 1：**

**输入：**[1,2,3,1]
**输出：**4
**解释：**偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。
     偷窃到的最高金额 = 1 + 3 = 4 。
     
不一定只隔着一个房间哦，比如`[15,1,2,16]你怎么偷？
## 题解
要写出状态转移方程
假设`dp[i]` 为截止第i个房间，行为所造成的最大收益
那与之前的有何关系？
第i个房间是可偷可不偷，如果偷，收益就是`dp[i-2] + nums[i]` 如果不偷，那就是`dp[i-1]` 
偷还是不偷？  看哪个收益最大嘛。
如果想当然，可能会觉得**如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警**。这个条件没有体现。注意，考虑`dp[i]` 时，应认为`i-1 i-2` 的房子都没确定是否被偷！（这也是我们初始化两个房子的原因）代入例子自己过一遍就清楚了，

| 房屋索引 (i) | 当前金额 (nums[i]) | 计算逻辑                                                | DP 值         | 决策含义                       |
| -------- | -------------- | --------------------------------------------------- | ------------ | -------------------------- |
| 0        | 15             | 初始化                                                 | `dp[0] = 15` | 偷第0间                       |
| 1        | 1              | `max(dp[0], nums[1])` → `max(15, 1)`                | `dp[1] = 15` | ​**不偷第1间**​（保留第0间的15）      |
| 2        | 2              | `max(dp[1], dp[0] + nums[2])` → `max(15, 15+2=17)`  | `dp[2] = 17` | ​**偷第2间**​（与第0间组合）         |
| 3        | 16             | `max(dp[2], dp[1] + nums[3])` → `max(17, 15+16=31)` | `dp[3] = 31` | ​**偷第3间**​（与第0间组合，跳过第1-2间） |
|          |                |                                                     |              |                            |


可以看到，每次都算是假设！

```python
 def rob(self, nums: List[int]) -> int:

        n = len(nums)

        dp = [0]*n

        dp[0] = nums[0]

        if n > 1:          

            dp[1] = max(nums[0],nums[1])

  

        for i in range(2,n):

            dp[i] = max(dp[i-1], dp[i-2] + nums[i])

  

        return dp[-1]

```
# 213 打家劫舍II
你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都 **围成一圈** ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，**如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警** 。

给定一个代表每个房屋存放金额的非负整数数组，计算你 **在不触动警报装置的情况下** ，今晚能够偷窃到的最高金额。

**示例 1：**

**输入：**nums = [2,3,2]
**输出：**3
**解释：**你不能先偷窃 1 号房屋（金额 = 2），然后偷窃 3 号房屋（金额 = 2）, 因为他们是相邻的。

## 题解

```python
class Solution:
    def rob(self, nums: List[int]) -> int:
        if len(nums) == 0:
            return 0
        if len(nums) == 1:
            return nums[0]
        
        result1 = self.robRange(nums, 0, len(nums) - 2)  # 情况二
        result2 = self.robRange(nums, 1, len(nums) - 1)  # 情况三
        return max(result1, result2)
    # 198.打家劫舍的逻辑
    def robRange(self, nums: List[int], start: int, end: int) -> int:
        if end == start:
            return nums[start]
        
        prev_max = nums[start]
        curr_max = max(nums[start], nums[start + 1])
        
        for i in range(start + 2, end + 1):
            temp = curr_max
            curr_max = max(prev_max + nums[i], curr_max)
            prev_max = temp
        
        return curr_max
```

## 打家劫舍 III
小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为 `root` 。

除了 `root` 之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果 **两个直接相连的房子在同一天晚上被打劫** ，房屋将自动报警。

给定二叉树的 `root` 。返回 _**在不触动警报的情况下** ，小偷能够盗取的最高金额_ 。

## 题解
```python
   # dp数组（dp table）以及下标的含义：
        # 1. 下标为 0 记录 **不偷该节点** 所得到的的最大金钱
        # 2. 下标为 1 记录 **偷该节点** 所得到的的最大金钱
        dp = self.traversal(root)
        return max(dp)

    # 要用后序遍历, 因为要通过递归函数的返回值来做下一步计算
    def traversal(self, node):
        
        # 递归终止条件，就是遇到了空节点，那肯定是不偷的
        if not node:
            return (0, 0)

        left = self.traversal(node.left)
        right = self.traversal(node.right)

        # 不偷当前节点, 偷子节点
        val_0 = max(left[0], left[1]) + max(right[0], right[1])

        # 偷当前节点, 不偷子节点
        val_1 = node.val + left[0] + right[0]

        return (val_0, val_1)
```