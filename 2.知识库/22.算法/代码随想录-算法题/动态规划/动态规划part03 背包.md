# 01背包


有n件物品和一个最多能背重量为w 的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。**每件物品只能用一次**，求解将哪些物品装入背包里物品价值总和最大

举例：
背包最大重量为4。
物品为：

|     | 重量  | 价值  |
| --- | --- | --- |
| 物品0 | 1   | 15  |
| 物品1 | 3   | 20  |
| 物品2 | 4   | 30  |
## 题解
设 `dp[i][j]` 是在背包重量是j的情况下，在0-i这些物品中取物品，能达到最大的价值是多少。
也就是说，我们现在3个物品，那是不是`dp[2][4]`就是我们最终的答案

怎么推导呢
依据下面的公式
```
 dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i])
```
同时，
可以写出下面的图
 ![[动态规划part03 背包-1750564633692.jpeg]]动态规划数组很容易写出来，重要的是理解为什么这么写，那先观察一下
1. 我们左侧的物品排序，是从小重量到大重量的；
2. 递推公式是两种情况的最大值
    1. 背包不选物品i。继承上一个状态
    2. 背包选择物品i，先＋上物品的价值，再加上“剩余容量的最优解”


进行解释
1. 假设就前两个物体（回看示例表格），这个从小重量到大重量排序的意义就好理解了吧。如果大重量做第一行，那`dp[0][1] ---> dp[0][2]` 不就全部为0了吧。这样没有初始化的味道，所以我们从小重量先考虑起。但没有初始化的味道 不= 错误哦     进阶部分再讲
2. 面临`dp[i][j]`(回看定义） 时情况就只能拆解为两种选择：选物体、不选物体。然后我们再想想，这两种选择分别怎样，才能尽可能最优。俩个分别都最优了，再从他们俩中选一次，就是最最优嘛。

```python
n, bagweight = 3, 4

weight = [1,3,4]

value = [15,20,30]

# 初始化

dp = [[0]*(bagweight+1) for _ in range(n)]

for i in range(weight[0],bagweight+1):

    dp[0][i] = value[0]

#动态规划

for i in range(1,n):

    for j in range(1,bagweight+1):

        if j < weight[i]:

            dp[i][j] = dp[i-1][j]

        else:

            dp[i][j] = max(dp[i-1][j],value[i]+dp[i-1][j-weight[i]])

  

print(dp[n-1][bagweight])

```
问题：
1. 那打乱顺序行不行呢？比如我就不从小往大，我从大往小，物品2--物品1--物品0，我甚至彻底无序，物品2--物品0--物品1   能或不能的理由是什么呢
2. 改变for循环顺序行不行呢？变成先容量，后物品

这些问题，放在
# 01背包进阶理解--一维数组
上面二维数组方法可以写出来，能不能用一维
‘即`dp[x]` 含义为背包容量为x时，背包的最大价值
以上面的例子，dp应该只有0---4 5个有效空间，这样是节省空间了。逻辑怎么写呢？
实际上是对二维的简化。重复i次就是反复更新这5个有效空间
我们需要注意的是，逆序遍历容量。因为我们的状态转移为
`dp[j] = max(dp[j], dp[j - weight[i]] + value[i])`
如果顺序，是不是就污染了`dp[j-weight[i]]`呢
```python
n, bagweight = 3, 4

weight = [2, 3, 4]

value = [15, 20, 30]

  

# 初始化一维DP数组

dp = [0] * (bagweight + 1)

  

# 动态规划过程

for i in range(n):              # 遍历物品

    for j in range(bagweight, weight[i] - 1, -1):  # 逆序遍历容量

        dp[j] = max(dp[j], dp[j - weight[i]] + value[i])

  

print(dp[bagweight])  # 输出35
```

|场景|是否允许|原因|
| ---| ---| --- |
|**二维DP打乱物品顺序**|✅ 允许|状态转移仅依赖上一行，与物品顺序无关。|
|**一维DP打乱物品顺序**|❌ 不允许（必须按原始顺序）|一维数组会覆盖状态，乱序可能导致重复计算或遗漏（见后续一维DP讲解）。|
|**二维DP打乱容量顺序**|✅ 允许（从小到大或从大到小均可）|状态转移不依赖同一行的其他状态。|
# 416 分割等和子集
给定一个只包含正整数的非空数组。是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。

注意: 每个数组中的元素不会超过 100 数组的大小不会超过 200

示例 1:

- 输入: [1, 5, 11, 5]
- 输出: true
- 解释: 数组可以分割成 [1, 5, 5] 和 [11].

示例 2:

- 输入: [1, 2, 3, 5]
- 输出: false
- 解释: 数组不能分割成两个元素和相等的子集.
## 题解
转化思维，众多数中，只要存在一组数，使得相加为二分之总和，就一定达到了题目的要求。

```python
 def canPartition(self, nums: List[int]) -> bool:

        if sum(nums) % 2 != 0:

            return False

        total = sum(nums)

        target = total//2

        dp = [0] * (target+1)

  

        for num in nums:

            for j in range(target,num-1,-1):

                dp[j] = max(dp[j],dp[j-num]+num)

  

        if dp[target] == target:

            return True

        else:

            return False
```
