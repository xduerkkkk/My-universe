# 完全背包
有N件物品和一个最多能背重量为W的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。**每件物品都有无限个（也就是可以放入背包多次）**，求解将哪些物品装入背包里物品价值总和最大。

**完全背包和01背包问题唯一不同的地方就是，每种物品有无限件**。

背包最大重量为4，物品为：

| |重量|价值|
|---|---|---|
|物品0|1|15|
|物品1|3|20|
|物品2|4|30|
`dp[i][j]` 仍然定义成，背包总容量为j时，考虑物品i的加入与否后，背包能装的最大价值。那与01背包的区别是什么呢？当然是物品i能加很多次！直到不了！而01是只能加1次
那我们借助dp的初始化思考完全背包
对于第一行，![[动态规划part05-1750675106395.jpeg]]
我们不要代码翻译“一直装直到装不下”，有点麻烦。
我们动态规划的核心思想，就是把当前的状态与之前的状态联系起来对不对？
对于初始化 
**从第一个物品的重量开始，每个容量下的最大价值 = 当前容量减去物品重量后的最大价值 + 当前物品的价值**
于是我们可以写出：
```
for i in range(weight[0],bagweight+1):  

    dp[0][i] = dp[0][i-weight[0]] + value[0]
```
当然，最关键的还是填满表格的逻辑
如果当前物品装不下背包里，那就沿用上一个状态（思考一下，沿用什么状态）
如果能装下，则先看看当前物品下，没有这个重量时的最大价值是多少，然后再加上当前物品价值

```
for i in range(1,n):

    for j in range(1,bagweight+1):

        if j < weight[i]:

            dp[i][j] = dp[i-1][j]

        else:

            dp[i][j] = max(dp[i-1][j],value[i]+dp[i][j-weight[i]])
```
`dp[i][j] = max(dp[i-1][j],value[i]+dp[i][j-weight[i]])`和·
`dp[i][j] = max(dp[i-1][j],value[i]+dp[i-1][j-weight[i]])`
就是完全背包和01背包二维版本，逻辑不同的地方

## 一维
上一个文章讲了01背包，一维时若顺序遍历，会出错。会错误地选择多个相同物品。哎呀呀，选择重复，不就是完全背包想要的吗？

```python
n, bagweight = 3, 4

weight = [1, 3, 4]

value = [15, 20, 30]

  

# 初始化一维DP数组

dp = [0] * (bagweight + 1)

for i in range(n):

    for j in range(weight[i], bagweight+1):

        dp[j] = max(dp[j],dp[j-weight[i]]+value[i])

  

print(dp[bagweight])
```
那同时，01背包的for循环，还必须先遍历物品再遍历容量
到了完全背包呢，都可以！只要满足正序遍历物品就行！


# 518 零钱兑换II
给你一个整数数组 `coins` 表示不同面额的硬币，另给一个整数 `amount` 表示总金额。

请你计算并返回可以凑成总金额的硬币组合数。如果任何硬币组合都无法凑出总金额，返回 `0` 。

假设每一种面额的硬币有无限个。 

题目数据保证结果符合 32 位带符号整数。

**示例 1：**

**输入：**amount = 5, coins = [1, 2, 5]
**输出：**4
**解释：**有四种方式可以凑成总金额：
5=5
5=2+2+1
5=2+1+1+1
5=1+1+1+1+1
## 题解

哎，有点难想，还蛮苦涩的
对于完全背包一维bp的理解要点在于：
- **如果求组合数就是外层for循环遍历物品，内层for遍历背包**。
- **如果求排列数就是外层for遍历背包，内层for循环遍历物品**

#### ✅ 正确性验证（Example: amount=5, coins=[1,2,5]）

|硬币|dp[0]|dp[1]|dp[2]|dp[3]|dp[4]|dp[5]|计算逻辑|
|---|---|---|---|---|---|---|---|
|初始|​**1**​|0|0|0|0|0||
|1|1|​**1**​|​**1**​|​**1**​|​**1**​|​**1**​|`dp[j] += dp[j-1]`|
|2|1|1|​**1+1=2**​|1+1=2|1+2=3|1+2=3|`dp[j] += dp[j-2]`|
|5|1|1|2|2|3|​**3+1=4**​|`dp[5] += dp[0]`|
 
| 问题类型    | 目标     | 典型转移方程                          |
| ------- | ------ | ------------------------------- |
| 传统完全背包  | 最大化价值  | `dp[j] = max(dp[j], dp[j-w]+v)` |
| 零钱兑换 II | 计数组合方式 | `dp[j] += dp[j - coin]`         |

```python
def change(self, amount: int, coins: List[int]) -> int:

        dp = [0]*(amount+1)

        dp[0] = 1

  

        for coin in coins:

            for j in range(coin,amount+1):

                dp[j] += dp[j-coin]

        return dp[amount]

```

# 377 组合总和IV
给你一个由 **不同** 整数组成的数组 `nums` ，和一个目标整数 `target` 。请你从 `nums` 中找出并返回总和为 `target` 的元素组合的个数。

题目数据保证答案符合 32 位整数范围。

**示例 1：**

**输入：**nums = [1,2,3], target = 4
**输出：**7
**解释：**
所有可能的组合为：
(1, 1, 1, 1)
(1, 1, 2)
(1, 2, 1)
(1, 3)
(2, 1, 1)
(2, 2)
(3, 1)
请注意，顺序不同的序列被视作不同的组合。
## 题解
类型是一模一样的
几个关键点再次强调一遍：
- `dp[0]` 等于1的原因
- 完全背包是正序遍历
- **如果求组合数就是外层for循环遍历物品，内层for遍历背包**。
- **如果求排列数就是外层for遍历背包，内层for循环遍历物品**
- 本题与上一题一个是求排列，一个是求组合

```python
  def combinationSum4(self, nums: List[int], target: int) -> int:

        dp = [0]*(target+1)

        dp[0] = 1

  

        for i in range(1,target+1):

            for num in nums:

                if i >= num:

                    dp[i] += dp[i-num]

        return dp[target]

```
