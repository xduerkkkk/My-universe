![[快速幂-1756628641164.jpeg]]

### 优化思路：从 O(k) 到 O(log k)

当遇到需要重复操作一个巨大次数 k 的问题时，我们通常要寻找一种更高效的方法，其时间复杂度往往与 log k 相关。一个经典的例子是“快速幂”，它可以在 O(log k) 的时间内计算 a^k。

本题也可以借鉴类似的思想，这个方法通常被称为**二进制提升 (Binary Lifting)** 或 **函数幂**。

核心思想如下：  
如果我们想知道从 n 开始操作 k 次后的结果，我们可以将 k 进行二进制分解。例如，k = 13，其二进制是 1101。  
13 = 8 + 4 + 1 = 2³ + 2² + 2⁰

所以，操作 13 次可以分解为：先操作 1 次，再在结果的基础上操作 4 次，最后再在结果的基础上操作 8 次。

这就要求我们能高效地计算“从任意数字 n 开始，操作 2^i 次的结果”。我们可以定义一个函数 jump(n, i) 来实现这个功能。

- jump(n, 0): 表示从 n 开始操作 2^0 = 1 次。这很简单，就是题目给的规则。
    
- jump(n, 1): 表示从 n 开始操作 2^1 = 2 次。这等价于先操作 1 次得到 n_mid = jump(n, 0)，再从 n_mid 开始操作 1 次，即 jump(n_mid, 0)。所以 jump(n, 1) = jump(jump(n, 0), 0)。
    
- jump(n, i): 表示操作 2^i 次。这可以分解为先操作 2^(i-1) 次，得到中间结果，再对这个中间结果操作 2^(i-1) 次。  
    所以我们得到了递推关系：**jump(n, i) = jump(jump(n, i-1), i-1)**。
    

为了避免重复计算，我们可以使用一个字典（或哈希表）来缓存 jump(n, i) 的计算结果。这个技术叫做**记忆化搜索 (Memoization)**。

### 优化后的算法步骤

1. **定义 jump(n, i) 函数**：
    
    - 接收当前数字 n 和指数 i (代表要跳 2^i 步) 作为输入。
        
    - **特殊情况处理**：如果 n 已经是 1，那么它会进入 1 -> 4 -> 2 -> 1 的循环。我们可以直接通过 2^i 对 3 取模来计算最终结果，无需继续递归。
        
    - **记忆化**：检查 (n, i) 是否已经计算过，如果计算过，直接返回结果。
        
    - **递归基石**：如果 i = 0，则执行单步操作（偶数除以2，奇数乘以3加1）。
        
    - **递归递推**：根据 jump(n, i) = jump(jump(n, i-1), i-1) 进行递归计算。
        
    - 将结果存入缓存并返回。
        
2. **主逻辑**：
    
    - 读取 n 和 k。
        
    - 从 k 的最高二进制位开始遍历 (大约是第 60 位，因为 2⁶⁰ > 10¹⁸)。
        
    - 如果 k 的第 i 位是 1，就意味着我们需要执行一次 2^i 步的跳转，即 n = jump(n, i)。
        
    - 循环结束后，得到的 n 就是最终结果。

```python
import sys

  

# 增大递归深度限制，因为我们的 jump 函数是递归的

sys.setrecursionlimit(2000)

  

# 使用一个字典来作为缓存，实现记忆化

memo = {}

  

def jump(n, i):

    """

    计算从数字 n 开始，执行 2^i 次操作后的结果。

    """

    # 如果 n 已经进入 1->4->2->1 的循环，可以直接计算结果

    # 修正后的 n=1 的情况

    if n == 1:

        # 2^i mod 3

        rem = pow(2, i, 3)

        if rem == 1: # i 是偶数, 走了 3k+1 步, 落在 4

            return 4

        else: # rem == 2, i 是奇数, 走了 3k+2 步, 落在 2

            return 2

  

    # 记忆化：如果 (n, i) 已经计算过，直接返回

    if (n, i) in memo:

        return memo[(n, i)]

  

    # 递归基石：i=0，代表只操作 1 次

    if i == 0:

        if n % 2 == 0:

            result = n // 2

        else:

            result = 3 * n + 1

        memo[(n, i)] = result

        return result

  

    # 递推关系：jump(n, i) = jump( jump(n, i-1), i-1 )

    # 先跳 2^(i-1) 步

    mid_point = jump(n, i - 1)

    # 再从中间点跳 2^(i-1) 步

    end_point = jump(mid_point, i - 1)

    memo[(n, i)] = end_point

    return end_point

  

def solve():

    n, k = map(int, input().strip().split())

  

    if k == 0:

        print(n)

        return

  

    # k 的二进制长度决定了 i 的最大值

    # 从高位向低位遍历

    for i in range(k.bit_length() - 1, -1, -1):

        # 如果 k 的第 i 位是 1，我们就跳 2^i 步

        if (k >> i) & 1:

            n = jump(n, i)

  

    print(n)

  

solve()

```
