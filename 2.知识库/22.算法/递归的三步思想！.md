1. 明确确定递归函数的参数和返回值 完全信任这个函数
2. 确定终止条件 想想最简单的情况
3. 确定单层递归逻辑   如何用我们第一步 信任的这个函数
在确定递归逻辑时，是将大问题分解成更小的同类问题。抱着这个心态去写逻辑。同时，确保问题向”终止条件“坍缩  

# 链表
## 反转链表
1. 我确定，我给递归函数传一个节点，递归函数会返回一下包括这个节点之后的反转链表 的 新头节点（已经成果反转的！）
2. 我如果发现，我后面没有节点了，那我就应该“反转自己”
3. 基于第一步，应该是我后面节点的反转链表指向我。

## 合并两个有序链表
我”就是**函数本身**。更具体地说，“我”是**当前这一层递归调用**。我的“管辖范围”，仅仅是传给我的list1和list2这两个**头节点**。
1. 我确定，我给递归函数两个链表，他直接返回的就是合并好的。我想给的是，我后面的链表。比如我手里是point1和point2 我给我后面的list   
2. 我如果发现，我后面没有list了，我就返回自己就行了，不用丢给递归函数了/。
3. 基于第一步，我把我后面的list1和lisst2 丢到函数里，就能返回合并好的。我需要思考的，只是”我“的去留？ 即point1和point2的去留？
  
**mergeTwoLists(list1, list2)这个函数，它本身就是‘我’。**  
**传进来的list1和list2，就是‘我’的全部世界。**  
**list1->next和list2，这不是‘我’丢给别人的东西，而是‘我’在调用‘另一个我’时，提供给他的、更简单的‘世界**

我觉得此时，三部曲第二个和第三个换顺序，更好思考点
1. mergeTwoLists函数，是我，也可以是我的小弟。这个函数承诺丢进去两个链表返回合并好的新链表的头节点
2. 我接收到的list1list2，我怎么最“最小”的动作，就是比较，得出新链表的第一个节点，这就够了，然后把剩下的链表丢给小弟。
3. 如果接收到的list1和list2 有一个是空 我直接返回另一个， 


# 二叉树
## 路径总和
**第一步：明确递归函数的参数和返回值，并完全信任它**

- **函数定义：** 我们需要一个函数，它能告诉我们“从当前节点出发，是否存在一条到叶子节点的路径，使得路径和等于一个给定的目标值”。
    
- **参数：**
    
    1. node: 当前我们正在检查的节点。
        
    2. targetSum: 从**根节点**走到**当前节点的父节点**后，还剩下多少目标值需要凑。
        
- **返回值：**
    
    - 题目要求返回 true 或 false，所以返回值是 布尔类型 (boolean)。
        

所以，我们的函数签名是： hasPathSum(self, node, targetSum)

- **信任它：** 现在，我们的大脑里要有一个信念：hasPathSum(node, sum) 这个函数是可靠的，只要我给它一个节点 node 和一个目标 sum，它就能正确地告诉我结果。我们不需要去想它内部怎么实现的，就当它是个黑盒子。


**第二步：确定终止条件（想想最简单的情况）**

- **情况1：节点是空的 None。** 如果传进来的节点是空的，那肯定不可能有路径了。这是最简单的基本情况。
    
    - **代码：** if not node: return False
        
- **情况2：节点是叶子节点。** 递归不能无限进行下去，走到叶子节点就是一条路径的终点。在这里，我们必须做出最终的判断，而不能再往下递归了。
    
    - **判断条件：** if not node.left and not node.right:
        
    - **逻辑：** 在这个叶子节点上，我们需要判断剩下的 targetSum 是否刚好等于当前叶子节点的值。
        
    - **代码：** return targetSum == node.val
        

**第三步：确定单层递归逻辑（如何用我们第一步信任的函数）**

这是最关键的一步。对于一个**非叶子节点 node**，我们怎么利用我们信任的 hasPathSum 函数来解决问题？

- **思考：** 对于当前节点 node 来说，一条从它出发的有效路径，要么是经过它的**左子树**走下去，要么是经过它的**右子树**走下去。只要**任何一边**能成功，那对于 node 来说就是成功的。
    
- **分解问题：**
    
    - 如果我们要走左子树，那么问题就变成了：**“在左子树中，是否存在一条到叶子节点的路径，其路径和等于 targetSum - node.val？”**
        
    - 这不就是我们第一步定义的函数吗！我们可以直接调用它：  
        hasPathSum(node.left, targetSum - node.val)
        
    - 同理，如果我们要走右子树，问题就变成了：  
        hasPathSum(node.right, targetSum - node.val)
        
- **组合结果：** 因为只要左边**或者**右边任何一条路能通就可以，所以我们用 or 来连接两个子问题的结果。

```python
class Solution:

    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:

        if not root:

            return False

        targetSum -= root.val

  

        if not root.left and not root.right:

            return targetSum == 0

  

        left_c = self.hasPathSum(root.left,targetSum)

        right_c = self.hasPathSum(root.right,targetSum)

  

        return left_c or right_c
```



# 翻转二叉树
每一个节点的左右俩个孩子都是反转的 整体就反转

以一个节点的视角看
坚信，invert函数，能让自己左孩子的子树全部反转，右孩子的子树全部反转。
那现在自己要做的是什么？ 就是将自己的左右孩子翻转而已。
不用return什么。
那特殊节点呢？ 发现自己是none，立马return了。
