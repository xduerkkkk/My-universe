
问题一：分割等和子集，把这个问题转换为 nums中是否有一个子集元素和为sum/2 我们可以假设有个sum/2容量的背包， 有经典背包最大价值的思路，我们看下这个背包，是否刚好装了sum/2 但为什么最大价值管用呢？？ 昨天是直接用最大价值做 没有思考为啥可以 总而言之，翻译的过程是翻译容量和价值。 容量就是sum/2 价值就是每个数本身的大小， 但感觉，有点奇怪，没有懂透彻  

问题二：i是第i个物品 j是容量 dp【i][j]是，在容量j的情况下，我们在0-i这些物品中，如何选择，使得背包价值最大，那个价值的大小就是dp【I][j]  
如果优化成dp【j】 我们要外层不断循环容量，从0循环到目标容量。在循环完后  
dp【j】的意思就是， 在目标容量下，我们看前j个物品，能使得背包最大价值的数  

问题三：

- 最大价值：dp[i][j] = max(dp[i-1][j] , dp[i-1][j-value] + value) 一维 dp[j] = max(dp[j] ,dp[j-1] + value)
    
- 方案总数，要满足j容量，只要俩种可能，不选当前物品和选当前物品。不选的话就用上一轮的容量但i-1个物品，选该物品的话， 就用之前的i-1个物品但容量是j-value ：dp[i][j] = dp[i-1][j] + dp[i-1][j-value] 一维dp[j] = dp[j] + dp[j-value]
- 从选优变成相加  

问题四：  
我们需要 “上一轮”的信息， 【i-1] 就是，我们要用到上一轮外循环的信息残留，如果正序就把信息残留全弄没了，所以倒序  
正序的话解决另一个模型？ 正序但代码不变的话.... 就说明当前外循环的物品，在背包里面。 那就是可以重复选当前外循环的物品，叫完全背包