# [416. 分割等和子集](https://leetcode.cn/problems/partition-equal-subset-sum/)

中等


给你一个 **只包含正整数** 的 **非空** 数组 `nums` 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。



```python
def canPartition(self, nums: List[int]) -> bool:
     
   total_sum = sum(nums)
        
        # 1. 前置判断：总和为奇数，不可能平分
        if total_sum % 2 != 0:
            return False
           
        max_value = total_sum // 2
        n = len(nums)
        dp = [[0]*(max_value + 1) for _ in range(n)]

        for j in range(max_value):
            if j >= nums[0]:
                dp[0][j] = nums[0]

        for i in range(n):
            dp[i][0] = 0
            

        for i in range(1,n):
            for j in range(1,max_value+1):
                if j < nums[i]:
                    dp[i][j] = dp[i-1][j]
                else:
                    dp[i][j] = max(dp[i-1][j],dp[i-1][j-nums[i]]+nums[i])

        return dp[-1][-1] == max_value
```


```python
def canPartition(self, nums: List[int]) -> bool:

        total_sum = sum(nums)

        if total_sum % 2 == 1:

            return False

        max_value = total_sum  // 2

  

        dp = [0]*(max_value+1)

  

        for num in nums:

            for j in range(max_value,num-1,-1):

                dp[j] = max(dp[j], dp[j - num] + num)

        return dp[max_value] == max_value

```


# 目标和

给你一个非负整数数组 `nums` 和一个整数 `target` 。

向数组中的每个整数前添加 `'+'` 或 `'-'` ，然后串联起所有整数，可以构造一个 **表达式** ：

- 例如，`nums = [2, 1]` ，可以在 `2` 之前添加 `'+'` ，在 `1` 之前添加 `'-'` ，然后串联起来得到表达式 `"+2-1"` 。

返回可以通过上述方法构造的、运算结果等于 `target` 的不同 **表达式** 的数目。

```python
def findTargetSumWays(self, nums: List[int], target: int) -> int:

        total_sum = sum(nums)

        # 前置判断：

        # 1. 如果目标绝对值大于总和，不可能达到

        # 2. 如果 (total_sum + target) 是奇数，不可能平分

        if abs(target) > total_sum or (total_sum + target) % 2 != 0:

            return 0

        # 数学转换，目标是找到一个子集 P，其和为 bag_size

        bag_size = (total_sum + target) // 2

        # dp[j] 代表装满容量 j 的背包，有多少种方法

        dp = [0] * (bag_size + 1)

        # 初始化：装满容量为0的背包，有1种方法（什么都不装）

        dp[0] = 1

        # 遍历物品

        for num in nums:

            # 遍历容量（必须倒序）

            for j in range(bag_size, num - 1, -1):

                # 状态转移：当前的方法数 = (不放num的方法数) + (放num的方法数)

                dp[j] = dp[j] + dp[j - num]

        return dp[bag_size]
```
