# 双指针
同向指针   “移动零”和“删除重复项”

异向指针
有序数组的平方 (Squares of a Sorted Array)** [https://leetcode.cn/problems/squares-of-a-sorted-array/](https://www.google.com/url?sa=E&q=https%3A%2F%2Fleetcode.cn%2Fproblems%2Fsquares-of-a-sorted-array%2F)


```c++
class Solution {

public:

    int subarraySum(vector<int>& nums, int k) {

        int len = nums.size();

        std::unordered_map<int,int> prefixCount;

        prefixCount[0] = 1;

        int ans=0, cur_sum = 0;

        for(int i = 0; i <  len; i++){

            cur_sum += nums[i];

            int targetPrefix = cur_sum-k;

            if (prefixCount.count(targetPrefix)) {

                ans += prefixCount[targetPrefix];

            }

            prefixCount[cur_sum]++;

        }

  

        return ans;

    }

};

```

- **战术名称：** 前缀和 + 哈希表
    
- **适用战场（问题特征）：**
    
    1. 处理 **连续子数组** 的问题。
        
    2. 问题与 **“和”** 相关。
        
    3. 数组中包含 **负数或0**（这使得滑动窗口失效）。
        
    4. 目标是求 **个数** 或 **是否存在** 满足条件的子数组。
        
- **核心转化逻辑（第一性原理）：**
    
    - 将求 sum(子数组[j..i]) 的问题，转化为求 prefixSum[i] - prefixSum[j-1]。
        
    - 将目标 prefixSum[i] - prefixSum[j-1] == k，移项为 prefixSum[j-1] == prefixSum[i] - k。
        
    - 最终，将一个“在 [0..i-1] 范围**搜索**一个下标 j”的 O(n) 问题，转化成了一个“在**历史记录**中**查询**一个值 prefixSum[i] - k 是否存在”的 O(1) 问题。
        
- **关键武器（数据结构）：**
    
    - **哈希表 (unordered_map):**
        
        - key: 历史上出现过的前缀和的值。
            
        - value: 该值出现过的次数。
            
- **关键细节（易错点）：**
    
    - 初始化 map[0] = 1，用于处理 nums[0..i] 本身就满足条件的情况。