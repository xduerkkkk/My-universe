# 同向双指针
## 使用场景
原地(in-place)、数组(array)、移除(remove)、移动(move)、保持相对顺序(maintain relative order)
## 核心思想
快慢指针，
慢指针坚守正确答案的阵地，这个区间内的所有元素，都是经过处理后，满足最终要求的。
快指针往前探索，去寻找那些“应该被纳入有效区间”的元素。
一旦 fast 侦察兵找到了目标，就将其“安置”在 slow 指针的“阵地”上，然后 slow 将阵地向前推进一格。
## 模板

```c++
定义fast，slow（同向，要么都是0，要么稍微fast提前一个）
while(fast<len) #fast要走完全部，所以用while
{
	if(....) #fast探索到某个特殊东西
	 {  swap，还是fast覆盖slow... 根据题意
	}
	fast++;
}

```


```c++
// 功能：原地修改数组nums，将满足条件的元素移动到数组前部
// 返回值：通常是新数组的有效长度
int function_name(vector<int>& nums) {
    // 1. 初始化慢指针，指向新数组的待插入位置
    int slow = 0;

    // 2. 快指针遍历整个原数组
    for (int fast = 0; fast < nums.size(); fast++) {
        
        // 3. 核心判断条件：判断 fast 指向的元素是否是我们“需要保留”的
        if (condition(nums[fast])) {
            
            // 4. 执行操作：将有效元素“安置”到 slow 的位置
            //    - 常见操作1：覆盖 (如“删除重复项”)
            //    - 常见操作2：交换 (如“移动零”)
            //    此处以“交换”为例，覆盖则更简单：nums[slow] = nums[fast];
            std::swap(nums[slow], nums[fast]);

            // 5. 慢指针前移，扩大有效区间的边界
            slow++;
        }
    }
    
    // 6. 返回新数组的有效长度
    return slow;
}
```


## 易错点
fast，slow初始化， 循环边界条件

# 首尾指针

## 使用场景
通常用于**已排序的数组**，或者问题涉及到需要从**数组的两端**向中间进行某种形式的“配对”或“比较”的场景。
当我们需要比较或组合数组两端的元素来构建最终结果时。

## 核心思想
一左一右 不断靠近，靠近之时就是遍历完整个数组之时
## 模板

```c++
定义left，right  
while(left<=right)# 也可以是小于，看题意，到底要不要处理最后一个中间数
{
进行处理

left++ right--
}

```

# 滑动窗口01

## 使用场景
当窗口扩张时，我们关心的指标会朝着一个方向变化（如 sum 变大）；当窗口收缩时，指标会朝另一个方向变化（如 sum 变小）。正因为如此，它适用于“正整数数组求和”，而不适用于“含负数的数组求和”。
## 核心思想
窗口本是0，然后右指针扩张， 左指针先不动，然后扩张到target条件以外后， 左指针移动，将窗口的老顾客踢走， 又是收缩，直至收缩到target条件
## 模板

```c++
int left = 0, right = 0;
for(right;right<nums.size();right++){#for循环代表了右指针的扩张

	while(window_state >= target){#当扩张到A条件以后
		
		window_state -= nums[left];
		left++; #处理窗口收缩的逻辑 左指针移动
	}
}

```

# 前缀和+哈希表
## 使用场景
用于解决**连续子数组**的**和等于/模等于**特定值 k 的问题，特别是当数组中包含**负数或0**，导致滑动窗口的“单调性”失效时。主要用于求满足条件的子数组的**个数**或**是否存在**。

- 关键词：连续子数组、和为k、包含负数/0、求个数。

## 核心思想
我们使用前缀和， 前缀和之差就是某一连续数组的和的思想
使用哈希表记录前缀和， 切忌不是 `index：前缀和`  而是`前缀和：个数`
## 模板

```c++
std::unordered_map<int,int> prefixCount;
prefixCount[0] = 1;应对前缀和本身就是target的情况
使用一次for循环
for(从头到尾) 一次遍历，同时计算前缀和、查询哈希表、更新哈希表
{
一边计算，记录前缀和
一边查哈希表，前面有没有我们想要的 prefixCount.count(targetPrefix)
我们直接ans += prefixCount[targetPrefix]
}

```

