Abstact:
1. C++项目从源代码到.exe文件，需要经历哪两个主要阶段？
首先要把所有的所有文件，包括头文件、cpp，全部进行编译，编译后的文件是.o
然后要把所有本次项目运行的.o 文件 粘合到一起，变成exe文件。运行这个exe文件就是运行项目设计的代码
2. .h文件和.cpp文件的核心分工是什么？
嗯...  .h文件是声明。 把完美需要的类写下来，最重要的是，类下面的构造函数内容、成员函数的具体内容都不用写，只用写个，，额，声明。 .h的作用就是，告诉xx（告诉谁啊？） xx有什么
.cpp是，在.h的基础上，详细给出操作内容的，函数是什么等等。
为啥要这样？我还是不太清晰，就觉得这样好吧，就想分开。
3. tasks.json的“使命”是什么？launch.json的“使命”又是什么？它们俩是如何通过preLaunchTask来“协同作战”的？
tasks是指如何编译，定义了编译的文件在哪，能批量编译，以及输出的exe在哪。
launch是正式运行exe文件的一些配置。所以launch的program 和task的输出的exe文件路径应该一样。 
这俩应该就是先激活task后激活launch吧？

4. 我们最终的“通用配置模板”中，"${fileDirname}/*.cpp"和"${workspaceFolder}/include"这两个参数，分别解决了什么问题？
`fileDirname/*cpp` 是当前文件的目录下，所有的cpp文件  
而workspacefolder指根目录    根目录的include有头文件
所以一个编译cpp一个编译头文件    

**R - Rebuild (重建与复现):**

- **任务：**
    
    1. **思想实验：** 假设我现在要添加一个BinaryTree的新模块，请您口头描述一下，需要在项目中新建哪些文件和文件夹？

	2. **口述流程：** 新建完文件后，我需要修改tasks.json或launch.json吗？如果不需要，我的完整操作流程是什么？（提示：从“点击激活main_tree.cpp”开始）
在src 建binarytree 俩个cpp文件  include的binarytree建头文件。
不修改了吧  我们点main_tree.cpp 然后直接f5 编译+运行
T：
解释清楚每个关键变量（${workspaceFolder}, ${fileDirname}, ${fileBasenameNoExtension}
workspaceFolder  当前根目录  filedirname 当前文件的文件夹   fileBasenameNoExtension
出现在"program": "${workspaceFolder}/build/${fileBasenameNoExtension}.exe",  就说用点击激活的cpp文件的名字 命名exe？