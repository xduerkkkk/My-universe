[[二叉树part01]]
# 前序遍历
stack 直接加入，node
while stack 一直pop

```python
def preorderTraversal(root):
    if not root:
        return []
    
    stack = [root]
    result = []

    while stack:
        node = stack.pop()
        result.append(node.val)
        if node.right:  # 先压入右孩子（因为栈是后进先出）
            stack.append(node.right)
        if node.left:
            stack.append(node.left)

    return result
```


# 中序遍历
stack先不急着加
先cur = node
然后再一路cur = cur.left 再加入stack
没有了left了，再pop我们的stack

```python
if not root:
	return []
  

ans = []
stack =  []
cur = node
while cur or stack:
	if cur:
		stack.append(cur)
		cur = cur.left
	else:
		cur = stack.pop()
		ans.append(cur)
		cur = cur.right
	

```

# 层序遍历

```cpp
class Solution {

public:

    vector<vector<int>> levelOrder(TreeNode* root) {

        std::vector<std::vector<int>> ans;

        if (root == nullptr) {

            return ans;

        }

        std::queue<TreeNode*> q;

        q.push(root);

        while (!q.empty()) {

  

            int level_size = q.size();

            std::vector<int> current_level;

  

            for (int i = 0; i < level_size; ++i) {

                TreeNode* node = q.front();

                q.pop();

                current_level.push_back(node->val);

  

                if (node->left != nullptr) {

                    q.push(node->left);

                }

                if (node->right != nullptr) {

                    q.push(node->right);

                }

            }

  

            ans.push_back(current_level);

        }

  

        return ans;

    }

};
```
