# 路径总和一

[112. 路径总和](https://leetcode.cn/problems/path-sum/)
给你二叉树的根节点 `root` 和一个表示目标和的整数 `targetSum` 。判断该树中是否存在 **根节点到叶子节点** 的路径，这条路径上所有节点值相加等于目标和 `targetSum` 。如果存在，返回 `true` ；否则，返回 `false` 。

**叶子节点** 是指没有子节点的节点。


```cpp
class Solution {

public:

    bool hasPathSum(TreeNode* root, int targetSum) {

        if(root==nullptr){return false;}

        if(root->left==nullptr&&root->right==nullptr&&targetSum == root->val){return true;}

        int new_targetsum = targetSum - root->val;

        return(hasPathSum(root->left,new_targetsum) || hasPathSum(root->right,new_targetsum));

    }

};

```




# 路径总和二 

[113. 路径总和 II](https://leetcode.cn/problems/path-sum-ii/)

给你二叉树的根节点 `root` 和一个整数目标和 `targetSum` ，找出所有 **从根节点到叶子节点** 路径总和等于给定目标和的路径。

**叶子节点** 是指没有子节点的节点。


```cpp
class Solution {

private:

    void findPaths(TreeNode* node, int targetSum, vector<int>& path, vector<vector<int>>& ans) {

        if (node == nullptr) {

            return;

        }

  

        path.push_back(node->val);

  

        if (node->left == nullptr && node->right == nullptr && node->val == targetSum) {

  

            ans.push_back(path);

  

        }

  
  

        findPaths(node->left, targetSum - node->val, path, ans);

        findPaths(node->right, targetSum - node->val, path, ans);

  

        path.pop_back();

    }

  

public:

    vector<vector<int>> pathSum(TreeNode* root, int targetSum) {

        vector<vector<int>> ans;

        vector<int> path;

        findPaths(root, targetSum, path, ans);

        return ans;

    }

};

```




# 路径总和三
[437. 路径总和 III](https://leetcode.cn/problems/path-sum-iii/)

中等

相关标签

![premium lock icon](https://static.leetcode.cn/cn-frontendx-assets/production/_next/static/images/lock-a6627e2c7fa0ce8bc117c109fb4e567d.svg)相关企业

给定一个二叉树的根节点 `root` ，和一个整数 `targetSum` ，求该二叉树里节点值之和等于 `targetSum` 的 **路径** 的数目。

**路径** 不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。

“连续子数组/子路径和”的问题，又一次用到了“前缀和”！！


```python
def pathSum(self, root: Optional[TreeNode], targetSum: int) -> int:

        # 1. prefix_map 和 ans 是整个递归过程共享的状态

        prefix_map = {0: 1}  # key: 前缀和, value: 出现的次数。初始化 {0:1} 很关键

        ans = 0

  
        # 2. 定义嵌套函数。它的参数是变化的量：当前节点和到它父节点为止的前缀和

        def dfs(node, current_sum):

            # 必须告诉 Python，我们要修改的是外层的 ans

            nonlocal ans

            # 递归的终止条件

            if not node:

                return

            # --- 核心逻辑 ---

            # a. 计算到当前节点为止的前缀和

            current_sum += node.val

            # b. 寻找是否存在满足条件的历史前缀和

            #    prefix_map 里存的是到达当前节点之前的那些前缀和

            ans += prefix_map.get(current_sum - targetSum, 0)

           # c. 将当前前缀和记录下来，给子节点使用

            prefix_map[current_sum] = prefix_map.get(current_sum, 0) + 1


            # --- 递归 ---

            #    将更新后的 current_sum 传递给子节点

            dfs(node.left, current_sum)

            dfs(node.right, current_sum)

            # --- 回溯 ---

            #    当此节点的所有子树都遍历完后，要把它的前缀和记录删掉

            #    这样才不会影响到它的兄弟节点

            prefix_map[current_sum] -= 1

        # 3. 启动递归

        #    初始调用时，我们站在一个“虚拟”的根节点之上，所以当前前缀和是 0

        dfs(root, 0)

        return ans
```
