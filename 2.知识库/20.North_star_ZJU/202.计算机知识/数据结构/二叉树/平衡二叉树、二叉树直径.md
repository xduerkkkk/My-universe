辅助性函数！自底向上！

# 平衡二叉树
一棵树是平衡二叉树  当且仅当

1. 它的 左子树 是平衡二叉树
    
2. 它的 右子树 是平衡二叉树
    
3. 当前节点左右子树高度差 ≤ 1

为什么？
这样的话，很容易顺着条件想，我们直接调用depth函数呗
对于1、2条件，我们信任我们的函数返回结果
3条件，利用depth函数左子树计算一下 右子树计算一下 看他们高度差


```python
	def depth(self,root):
		if not root:
			return 0
		return max(depth(root.left),depth(root.right))+1
	def isBalanced(self,root):
		if not root:
			return True
		return(abs(self.depth(root.left) - self.depth(root.right)) <= 1
			and self.isBalanced(root.left) and self.isBalanced(root.right))

```
一直在重复遍历！ 第一次调用depth(root.left) 就已经把左子树全遍历完了
后续肯定要继续遍历的

那我们就想 直接让函数，从下往上走， 顺带着信息。


这才是解决这道题的最佳姿势。既然我们在计算一个节点的深度时，无论如何都已经拿到了它左右子树的深度，我们为什么不**在计算深度的同时，顺便检查一下它是否平衡呢？**

我们可以改造一下 `depth` 函数，让它返回一个“特殊信号”来告诉我们子树是否已经不平衡了。

**让我们为改造后的 `depth` 函数建立一个新的“契约”：**

*   **新契约**：`check_depth(node)` 函数将返回：
    *   如果以 `node` 为根的子树是**平衡的**，则返回它的**真实深度**（一个非负数）。
    *   如果以 `node` 为根的子树是**不平衡的**，则返回一个**特殊信号 `-1`**。

现在，我们用“三步走”框架来构建这个新的 `check_depth` 函数：

1.  **契约**：如上所述。
2.  **终点 (Base Case)**：如果 `node` 为空，那么它既是平衡的，深度又是 0。所以 `if not root: return 0`。
3.  **分解与组合 (Recursive Step)**：
    *   **分解与调用**：我不知道左右子树的情况，但我相信我的“专家”！
        ```python
        left_depth = check_depth(root.left)
        right_depth = check_depth(root.right)
        ```
    *   **组合与检查**：现在我拿到了 `left_depth` 和 `right_depth`。我需要做两件事：
        1.  **检查“下属”是否已经报告了问题**：如果 `left_depth` 或 `right_depth` 中任何一个等于 `-1`，说明下面的子树已经不平衡了。我得立刻把这个坏消息传递上去，所以 `return -1`。
        2.  **检查我自己的平衡情况**：如果下属们都没问题，我再看看我自己。如果 `abs(left_depth - right_depth) > 1`，说明问题出在我这一层，我也得报告不平衡，所以 `return -1`。
        3.  **一切正常！** 如果上面两个检查都通过了，说明到我这一层为止，一切都是平衡的。那我应该向上级报告什么？当然是我的真实深度：`return max(left_depth, right_depth) + 1`。

**最终的代码实现：**

```python

class Solution:
    def isBalanced(self, root: Optional[TreeNode]) -> bool:
        # 主函数只需要调用辅助函数，并检查最终的返回结果是不是-1即可
        return self.check_depth(root) != -1

    def check_depth(self, root: Optional[TreeNode]) -> int:
        # Base Case: 空树是平衡的，深度为0
        if not root:
            return 0

        # 递归调用左右子树
        # 相信它们会返回真实深度，或者-1（如果不平衡）
        left_depth = self.check_depth(root.left)
        # 如果左子树已经不平衡，没必要继续了，直接层层返回-1
        if left_depth == -1:
            return -1
            
        right_depth = self.check_depth(root.right)
        # 如果右子树不平衡，同理
        if right_depth == -1:
            return -1

        # 检查当前节点是否平衡
        if abs(left_depth - right_depth) > 1:
            return -1
        
        # 如果都平衡，返回当前节点的深度
        return max(left_depth, right_depth) + 1
```

ART:
自顶向下版，是从最高节点开始，每一层都进行宏观的，条件思考。
而条件中，有一个条件是左右子树高度差小于等于1，那势必要计算高度差。
如果自顶向下，那第一层计算高度时就会把整棵树遍历了一遍，计算长度。第二层呢，又会遍历下面的。所以造成了重复。  
而自底向上呢，直接从最底部携带信息往上走，这样就没有重复计算长度，只遍历一次，是on的复杂度

```cpp
int get(root){
if(root==nullptr){return 0;}
left_depth = get(root->left);
if(left_depth==-1){return -1;}
right_depth = get(root->right);
if(right_depth==-1){return -1;}

//如果都平衡，再检验一下会不会到我们这个节点发生不平衡
if(abs(left_depth-right_dpeth)>1){return -1;}
return max(left_depth,right_depth) + 1; //这里是正常计算深度

}

```




思路二（我们今天不实现，但需要理解）：迭代法
要判断每个节点的左右子树高度差，我们需要先知道子树的高度。
而计算一个节点的高度，需要先知道它孩子节点的高度。
这种“需要先处理完子问题，再回头处理父问题”的模式，天然地契合了哪种遍历顺序？（后序遍历）
因此，这道题的迭代解法，就是一次“**魔改”的“后序遍历”**。我们需要在遍历过程中，用一个哈希表(map<TreeNode*, int>)来记录和查询每个节点的高度。这个解法非常复杂，我们今天不要求实现，但您需要理解它与“后序遍历”的内在联系。



# 二叉树直径
**我们用“三步走”框架来构建这个 helper 函数：**

1. **契约**：如上所述。
    
2. **终点 (Base Case)**：如果 node 为空，它的深度是 0。if not root: return 0。
    
3. **分解与组合 (Recursive Step)**：
    
    - **分解与调用**：我需要左右子树的深度来做计算。没关系，我的“专家”会告诉我！
        
        codePython
        
        ```
        left_depth = helper(root.left)
        right_depth = helper(root.right)
        ```
        
    - **组合与副作用**：现在我拿到了 left_depth 和 right_depth 这两个完美的结果。
        
        1. **计算穿过我 root 的路径长度**：diameter_at_this_node = left_depth + right_depth。
            
        2. **更新全局最大值**：我需要一个变量（比如 self.max_diameter）来记录到目前为止见过的最大直径。self.max_diameter = max(self.max_diameter, diameter_at_this_node)。
            
    - **履行我的返回承诺**：我的函数契约要求我返回**当前节点的深度**。这个深度是多少？是 max(left_depth, right_depth) + 1。
        

**最终的代码实现：**

```Python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def diameterOfBinaryTree(self, root: Optional[TreeNode]) -> int:
        # 我们需要一个变量来记录全局的最大直径
        # 使用列表或字典等可变对象，或者直接用 self.max_d
        self.max_diameter = 0
        
        # 调用辅助函数来启动递归
        self.depth_and_update(root)
        
        return self.max_diameter

    def depth_and_update(self, root: Optional[TreeNode]) -> int:
        # Base Case: 空节点的深度为0
        if not root:
            return 0

        # 递归地计算左右子树的深度
        left_depth = self.depth_and_update(root.left)
        right_depth = self.depth_and_update(root.right)

        # 副作用：计算穿过当前节点的直径，并尝试更新全局最大值
        current_diameter = left_depth + right_depth
        self.max_diameter = max(self.max_diameter, current_diameter)

        # 履行承诺：返回当前节点的深度
        return max(left_depth, right_depth) + 1
```