DFS的迭代，我们要手动模拟栈。，咦，感觉，一直都是直觉，缺一个逻辑环。
就是感觉，如果面试为我，到底为什么模拟栈，我不能快速精确地组织语言。大概是，要把一个“家族”的成员全部处理完才能处理第二个家族，体现“深”
BFS的迭代，我们使用队列，我们是把一层处理完，每一层孩子都在后面，一层家族之首全部处理完再处理他们的孩子。

DFS递归遍历：
- 前序 一碰到根节点就记录，然后是先让左子树继续递归，后让右子树继续递归
- 中序 先让左子树递归，递归完后 记录自己的值 再让右子树继续递归’
- 后序...一样的
DFS迭代遍历：
前序 一碰到根节点就要记录，然后先压栈右子树，再压栈左子树，这样弹栈先弹左
中序，一直去找左子树，直到nullptr了开始弹回父节点，然后又一直去找右子树
后序的话， 前序流程换一下左右子树压栈流程，然后最好reverse一下结果。

一棵树，只给前序后序，好像不太能确定树。因为跟左右 左右跟  左和右还是不清楚啊，到底哪些是左哪些是右。而中序和后序，左根右，左右根，是ok的，所以中序和前序也是ok的

中序遍历的递归和迭代：

```cpp
inorder(root->left);
res.push_back(root);
inorder(root->right);

```


```cpp
while(cur || s ){
	if(cur)
	{s.push(cur);
	cur = cur->left;}
	else
	{
	cur = s.top();
	s.pop();
	res.push_back(cur);
	cur = cur->right;
	}
	
}

```

前序迭代遍历

```cpp
while(s)
{
	Treenode* node = s.top();
	s.pop();
	res.push_back(node);
	if(s->right){s.push(s->right)};
	if(s->left){s.push(s->left)};
}
```

对比前序和中序迭代遍历，前序是一弹出s，就开始记录。而最开始直接是第一个根节点。
中序，就是if(cur) 一种cur = cur- > left ，入s但不记录。直到变成空，再弹出空的父节点，再记录这个父节点。然后再去右子树

层序遍历 

```cpp
while(!q.empty())
{
 cur = ... 

 q_size = q.size();
 q.pop();
 for(i = 0;i <q_size; i++){
	 //伪代码
	 Treenode* node = q.front();
	 current_level.push_back(node->val);
	 if(left){入队}
	 if(right){入队}
 
 }
 ans.push_back(cur);
 }

```
