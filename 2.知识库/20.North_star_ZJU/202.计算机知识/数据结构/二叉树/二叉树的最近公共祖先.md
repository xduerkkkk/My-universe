p、q分布位于公共祖先的左右子树，或者p是q的祖先
提到子树，就想想能不能递归（有更好的思维链吗？）
怎么思考？
选择的思考者，就是一个节点。 因为每一个节点都有可能是所谓公共祖先。
那么站在节点的视角，我们要干什么呢？
假如左子树有p，右子树有q，呀，那我就是祖先啊（只要发现就认定我是祖先，我比谁都快，所以一定是最近）
假如某一个子树有，另一个子树没有，哎无所谓，只要有一个子树有，对于我的上级，v此时此刻的”我“，就是携带哪个有的子树的p/q。
如果都没有 如实继续汇报。

当然，这个思考者我们是以”最多者“去想的
还有少者情况，这些少者，或者说特殊情况，叫递归终止的关键，我们还要替他们想想
如果自身就是none，返回none
如果自身就是p/q，呀那直接返回我自己。

```cpp
class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        // --- 终止条件 & "我就是目标" 的情况 ---
        // 1. 如果树为空，或者我root自己就是p或q，那么我就把自己返回
        //    这既是终止条件，也是向上汇报“线索”的关键
        if (root == nullptr || root == p || root == q) {
            return root;
        }

        // --- “甩锅”给左右孩子 ---
        // 2. 去左、右子树，分别寻找p和q的线索
        TreeNode* left_result = lowestCommonAncestor(root->left, p, q);
        TreeNode* right_result = lowestCommonAncestor(root->right, p, q);

        // --- 汇总情报，做出本层决策 ---
        // 3. 情况A：左右两边都返回了“有效线索”
        //    说明p和q分列在我的两侧，那我(root)就是LCA
        if (left_result != nullptr && right_result != nullptr) {
            return root;
        }
        
        // 4. 情况B/C/D：
        //    如果只有左边有线索，说明LCA在左边，把左边的线索传上去
        //    如果只有右边有线索，说明LCA在右边，把右边的线索传上去
        //    如果两边都没线索，结果也是nullptr，也正确
        return left_result != nullptr ? left_result : right_result;
    }
};

```
