### **二叉树递归的两大心智模型**

所有二叉树的递归问题，你都可以先问自己：“我是谁？”，然后代入下面两个模型中的一个。

#### **模型一：“观察者”模型 (“朴素节点视角”)**

- **我是谁？** 我是树中一个**已经存在**的、普普通通的节点。我有父节点（虽然我不在乎它是谁），也可能有左、右孩子。

- **我的任务是什么？** 我的任务是**处理**以我为根的这棵**局部子树**，或者利用我的子树信息**向上汇报**。我信任我的孩子们能处理好它们的子树。

- **适用问题类型：**
    
    - **所有对“已存在”的树进行遍历、查询、修改的操作。**
        
    - **例子**：求最大深度、翻转二叉树、路径总和、LCA、验证/搜索/插入/删除BST... **（我们做过的大部分题都属于这个模型）**

#### **模型二：“创造者”模型 (你所说的“蓝图创造者视角”)**

- **我是谁？** 我是一个“**建筑工”**。我手里没有树，只有一份或多份**“蓝图”**（比如数组、字符串）。
    
- **我的任务是什么？** 我的任务是根据蓝图，**从无到有**地建造一棵树（或子树）。我的核心工作是先**创建出当前的根节点**，然后把剩下的蓝图分给我的“下级承包商”（递归调用），让他们去建造左右子树。
    
- **适用问题类型：**
    
    - **所有需要根据外部数据来构建一棵树的操作。**
        
    - **例子**：从前序和中序遍历构造二叉树、序列化与反序列化。
        

---

### **两大信息流方向**

现在，无论你选择了哪个模型，你在“工作”时，信息总是在流动。这个流动只有两个方向，

#### **信息流一：自底向上汇集信息 (通过 return 值)**

- **流动方式**：信息从树的底部（叶子节点）通过函数的 return 语句，层层向上传递，最终汇集到根节点。 这里必须是递归函数

- **工作模式**：我（父节点）**必须等待**我的左右孩子（递归调用）先完成工作并把**结果汇报**给我，我才能根据它们的汇报，结合我自身的情况，做出决策或计算出我这一层的结果，再向上汇报。

- **经典应用**:
    
    - **求最大深度**：孩子们返回它们各自的深度，我取最大值加一。
    - **LCA (最近公共祖先)**：孩子们返回它们是否找到了 p 或 q，我根据两边的返回结果来判断LCA是不是我自己。p或q就指他们有p或q，nullptr的话就是什么也没找到。
    - **判断平衡二叉树**：孩子们返回它们的高度和是否平衡，我综合判断，返回-1说明不平衡，此时高度都没用。返回正常数字的话，这个正常数字就是他们的高度。



```cpp
int get(root){
if(root==nullptr){return 0;}
left_depth = get(root->left);
if(left_depth==-1){return -1;}
right_depth = get(root->right);
if(right_depth==-1){return -1;}
// 这里，我们计算深度仍用的是get，而不是独立的depth函数，就是自底向上传递信息的关键。

if(abs(left_depth-right_dpeth)>1){return -1;}
return max(left_depth,right_depth) + 1; //这里是正常计算深度

}

```


#### **信息流二：自顶向下传递信息 (通过 parameters 参数)**

- **流动方式**：信息/约束从根节点开始，通过递归函数的**参数**，层层向下传递给子节点。
    
- **工作模式**：我（父节点）在调用我的孩子（递归调用）时，会根据我自身的情况，给它们**附加一些指令或限制**。它们必须在这些限制下完成工作。
    
- **经典应用**:
    
    - **验证BST**：我告诉我的左孩子：“你的值不能超过我”，告诉我的右孩子：“你的值不能低于我”。这个“上下界约束”就是通过参数传递下去的。
        
    - **路径总和**：我把我这里剩下的 targetSum 传递给我的孩子们，让它们继续去凑数。
        

---

### **如何应用这个框架**


1. **第一步：选择心智模型**
    
    - 题目是让我处理一棵现成的树吗？ -> **“观察者”模型**。
        
    - 题目是让我根据一些数据造一棵树吗？ -> **“创造者”模型**。
        
2. **第二步：确定信息流方向**
    
    - 我需不需要子问题的**计算结果**来帮助我决策？ -> **自底向上**（关注 return 值）。
        
    - 我需不需要把我这一层的**状态或约束**告诉我的子问题？ -> **自顶向下**（关注 parameters）。
        
    - （有时两者会结合，但总有一个是主要的）
        

**举例：**

- **LCA** -> “观察者”模型 + “自底向上”信息流。
    
- **验证BST** -> “观察者”模型 + “自顶向下”信息流。
    
- **构造二叉树** -> “创造者”模型 + “自顶向下”的信息流（把划分好的蓝图范围通过参数传下去）。


# parent
为了修正上面的设计缺陷，我们需要让每一层的递归调用，都**自己决定自己**的 count 是多少。

**dfs(node) 的视角：**

> “我是节点 node。我需要知道我的长度是多少。我的长度取决于我的值 node.val 和我父节点的值 parent_val 是否相等。但是我怎么知道我父节点的值呢？我没法向上看。”

这就引出了解决方案：

> “既然我没法向上看，那就让我的父节点在调用我的时候，**通过参数把它的值告诉我**！”