之前的思考者，是站在已有节点上的观察者
今天是一个建筑工

# 从前序和中序遍历序列构造

什么样的递归构造是最好的？
一定是拿到信息/蓝图，然后把左右子树构造好的。
然后左右子树也这么干的！


得多刷啊

```python
class Solution:

    def buildTree(self, preorder: List[int], inorder: List[int]) -> Optional[TreeNode]:

        inorder_map = {v:i for i,v in enumerate(inorder)}

        def build(pre_start,pre_end,in_start,in_end):

            if pre_start > pre_end or in_start > in_end:

                return None

  

            root_val = preorder[pre_start]

            root = TreeNode(root_val)

            in_root_idx = inorder_map[root_val]

            left_subtree_size = in_root_idx - in_start

  

            root.left = build(pre_start + 1, pre_start + left_subtree_size, in_start, in_root_idx - 1)

            root.right = build(pre_start + left_subtree_size + 1, pre_end, in_root_idx + 1, in_end)

            return root

  

        return build(0, len(preorder) - 1, 0, len(inorder) - 1)
```
# 序列化和反序列化
看到node.val 好好想想有没有判断val是不是NUll！
无论何时都问下自己有没有考虑边界情况！
很糟糕

反序列化时 两个队列
实际每个节点既做了连接父节点，又做了寻找子节点
首先datalist 一个队列，暂时只放一个头节点   parent_node一个队列，找孩子的父亲们
先把datalist的头节点放出来 放进parent_node里
然后datalist pop出俩  一个是当前parent的左孩子 一个是右孩子
这俩pop出不着急，立马又进parent_node 去当别人的爸爸