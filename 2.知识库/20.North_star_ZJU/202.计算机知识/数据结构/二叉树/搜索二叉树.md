# 验证搜索二叉树

仍然递归 我们是传递信息的递归，从上到下。 我们相信，递归函数传给我们的孩子，孩子会自己验证。   观察者，为中间的朴素节点。 假设它是根节点A的右孩子， 节点B，上面传递了lower 和  upper     upper不知道，无限大，但lower一定是父节点。  看来我们并不清楚根节点的孩子并不朴素。我们再走一步。 
假如我们是节点B的左孩子。  我们拿到的蓝图，其中upper应该是父节点， lower呢，应该是父节点的父节点的lower！
假如我们是节点B的右孩子，我们拿到的蓝图，upper应该也无限大？  所以应该是父节点的upper？  lower，就是父节点。
所以我们回到节点B的视角，我们传给左孩子的upper。是自身，lower，是自己当初拿到的lower。  传给右孩子的lower，是自身， upper是自己当初拿到的upper。
直接上可以理解，对于左孩子， 要比自己还小，upper应该更新最小的，即自己。 lower就拿之前的就好了。  右孩子同理。

中序遍历检验是否递增，可以一边遍历一边设置个temp保存上一个值 只要当前值大于 temp 就ok 然后把自己变成temp 下一个值继续判断。



```python
if not root:
	return []
  

ans = []
stack =  []
temp = -inf
cur = node
while cur or stack:
	if cur:
		stack.append(cur)
		cur = cur.left
	else:
		cur = stack.pop()
		if cur < temp:
			return False
		temp = cur
		cur = cur.right
	
```
或递归做中序

```python
class Solution:
    def __init__(self):
        self.prev = float('-inf')

    def isValidBST(self, root: Optional[TreeNode]) -> bool:
        if not root:
            return True
        
        # 1. 先递归判断左子树
        if not self.isValidBST(root.left):
            return False
            
        # 2. 然后处理当前节点 (中序位置)
        if root.val <= self.prev:
            return False
        self.prev = root.val
        
        # 3. 最后递归判断右子树
        return self.isValidBST(root.right)
```


```cpp
class Solution {

private:

    bool exam(TreeNode* root, long long lower_bound, long long upper_bound){

        if(root==nullptr){return true;}

        if (node->val <= lower || node->val >= upper) {

            return false;

        }

  

        return isValid(node->left, lower, node->val) &&

               isValid(node->right, node->val, upper);

    }

  
  

public:

    bool isValidBST(TreeNode* root) {

        return exam(root, std::numeric_limits<long long>::min(),

                             std::numeric_limits<long long>::max());

    }

};

```




# 搜索二叉树的搜索和插入
定义递归：检索， 就把自己当前检索好，剩下交给孩子  传入的就只有node和val吧?
单层逻辑：应该有恒定的val 每一个节点视角都能看到
比较自身 
如果是自己，好   返回子树 打印成列表
如果比自己小 去左孩子 比自己大 去右孩子
极端情况：
如果自己是空，那都到我这里还没找到，就返回null

```python
class Solution:
    def searchBST(self, root: Optional[TreeNode], val: int) -> Optional[TreeNode]:
        # 终止条件1: 树为空，或者走到空节点了，说明没找到
        if not root:
            return None
        
        # 单层逻辑
        if root.val == val:
            # 找到了！根据契约，返回这个节点本身 (TreeNode 对象)
            return root
        
        if root.val < val:
            # 目标值更大，说明应该在右子树。
            # 我们完全信任递归调用，它会在右子树中帮我们完成剩下的工作，
            # 并返回正确的结果 (TreeNode 或 None)
            return self.searchBST(root.right, val)
        else: # root.val > val
            # 目标值更小，去左子树找
            return self.searchBST(root.left, val)

```

```python
class Solution:
    def searchBST(self, root: Optional[TreeNode], val: int) -> Optional[TreeNode]:
        # cur 指针从 root 开始
        cur = root
        # 只要还没走到空节点
        while cur:
            if cur.val == val:
                return cur # 找到了
            elif cur.val < val:
                cur = cur.right # 往右走
            else:
                cur = cur.left # 往左走
        # 循环结束说明走到了空节点，没找到
        return None
```


插入的话 只要在搜索代码的基础上，发现null时 连接父亲就好了？
准确来说 是 让父亲连接自己

```python
def insertIntoBST(self, root: Optional[TreeNode], val: int) -> Optional[TreeNode]:

        if not root:

            return TreeNode(val)

        if val >root.val:

            root.right = self.insertIntoBST(root.right,val)

        if val < root.val:

            root.left = self.insertIntoBST(root.left,val)

  

        return root
```

# 删除二叉树
首先定位节点很容易 像上题一样迭代寻找
我们直接讨论最复杂的状况 被删除的节点有两孩子。
两孩子的孩子就不管了，我们把这俩孩子安顿好其他孙子跟着就行了。
其实这俩孩子，都满足比删除节点的父节点小啊。 假设左孩子A右孩子B
左孩子A接替父亲 右孩子B变左孩A的右孩子
或  右孩子B接替父亲， 左孩子A变右孩B的左孩子。

错！ 谁说孙子跟着就行了！
接任节点不能是简单的左孩子或右孩子。  能挑起大梁的，应该是右孩子中最小的那个，或左孩子中最大的。我们用右孩子最小的



本题和上题插入， 一样，是递归返回root  是连接递归函数传来的left或right 实

```python
class Solution:

    def deleteNode(self, root: Optional[TreeNode], key: int) -> Optional[TreeNode]:

        if not root:

            return None

        # 2. 递归寻找

        if key < root.val:

            root.left = self.deleteNode(root.left, key)

        elif key > root.val:

            root.right = self.deleteNode(root.right, key)

        # 3. 找到了！key == root.val，开始处理删除逻辑

        else:

            # 情况一和二：没有左孩子或没有右孩子

            if not root.left: return root.right

            if not root.right: return root.left

            # 情况三：左右孩子都在

            # a. 找到右子树的最小节点 (继任者)

            cur = root.right

            successor = root.right

            while successor.left:

                successor = successor.left

            # b. 值的“灵魂互换”

            root.val = successor.val

            # c. 转化问题：去右子树里删除那个继任者节点

            root.right = self.deleteNode(root.right, successor.val)

        # 4. 返回当前（可能被修改过的）子树的根

        return root

```
