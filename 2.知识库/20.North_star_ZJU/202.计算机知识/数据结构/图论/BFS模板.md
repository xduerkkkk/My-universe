对于BFS题，思想很简单，我们可以想象，是涟漪一样的扩散
只不过都发生在网格里，一个点的扩散，带动的恰好是周围一圈，8个方向。
所以，我们要定义方向

```cpp
int dr[] = {-1,-1,-1,0,0,1,1,1}
int dc[] = {-1,0,1,-1,1,-1,0,1}
```
上下对应起来看，非常的清晰。

当然，不一定8个方向都扩散，因为可能已经有扩散过。
所以一般，我们有visited数组。

```cpp
// 假设网格的行数为 n，列数为 m 
int n = grid.size(); 
int m = grid[0].size();

可能我们要初始化为bool，则
std::vector<std::vector<bool>> visited(n,std::vector<bool>(m,false));

std::vector<std::vector<int>> visited(n,std::vector<int>(m,0));
```
不过，对于特殊的题，比如题目中有障碍物这种，我们直接可以使用
`grid[a][b]=1或=0`来标记是否访问。

扩散，一定是从某一个点开始的。
我们一般选择的是第一行第一列这个元素。
我们扩散后，就能找到 下一步我们要扩散的，8个方向的兄弟。
这些兄弟，我们要存储。
同时，也许题目有要求，也不能和我们此时扩散的节点们混杂了，要有”层“的概念，让我们知道这是第几层。
很像二叉树的层序遍历。
这时我们使用队列+for循环。
但如果题目没有要求，可以混杂，那就不需要for循环，一定要明白for循环的用处

怎么存储要扩散的兄弟？我们存储的坐标，所以是pair形式 。
只要队列不空，我们就进行操作。
一个一个弹出，
弹出后可以先操作，根据题目.
然后就进入我们广度遍历的精髓，添加需要后续需要扩散的兄弟。
使用for循环遍历每个方向，还要注意有没有碰墙

```cpp
std::queue<std::pair<int,int>> q;
q.push({0,0}) //一般我们选择的是第一行第一列这个元素，作为扩散起点

while(!q.empty())
{
	auto [r,c] = q.front();
	q.pop();
	
	根据题目，判断条件/进行操作
	
	for(int i = 0; i< 8; i++)
	{
		int nr = r + dr[i];
		int nc = c + dc[i];
		if(nr >= 0 && nr < n && nc >= 0 && nc < m && 没有访问 && 可以再增加扩散的条件，比如grid[nr][nc] == 0)
	{   标记已访问
		q.push({nr,nc});
		
	 }
	}

	
}

```
