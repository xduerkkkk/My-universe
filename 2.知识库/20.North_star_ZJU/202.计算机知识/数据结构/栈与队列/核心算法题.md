# [155. 最小栈](https://leetcode.cn/problems/min-stack/)


设计一个支持 `push` ，`pop` ，`top` 操作，并能在常数时间内检索到最小元素的栈。

实现 `MinStack` 类:

- `MinStack()` 初始化堆栈对象。
- `void push(int val)` 将元素val推入堆栈。
- `void pop()` 删除堆栈顶部的元素。
- `int top()` 获取堆栈顶部的元素。
- `int getMin()` 获取堆栈中的最小元素


- **核心思想：** 辅助栈min_stack同步维护最小值的“历史变迁”。
    
- **关键点：** push时，若val <= min_stack.top()，则min_stack也push。pop时，若pop_val == min_stack.top()，则min_stack也pop。


```cpp
void push(int val){
	data_stack.push(val);
	if(min_stack.empty()||val<=min_stack.top())//注意小于等于
	{min_stack.push(val);}
}
void pop(){
	if(data_stack.top()==min_stack.top()){ min_stack.pop();}
	data_stack.pop();
}
```

# [20. 有效的括号](https://leetcode.cn/problems/valid-parentheses/)

给定一个只包括 `'('`，`')'`，`'{'`，`'}'`，`'['`，`']'` 的字符串 `s` ，判断字符串是否有效。

有效字符串需满足：

1. 左括号必须用相同类型的右括号闭合。
2. 左括号必须以正确的顺序闭合。
3. 每个右括号都有一个对应的相同类型的左括号。


- **核心思想：** 使用栈。遇到左括号，入栈；遇到右括号，检查栈顶的左括号是否与它匹配。
    
- **关键点：**
    
    1. 使用哈希表map<右, 左>，可以优雅地处理匹配关系。
        
    2. 遇到右括号时，**必须先判断栈是否为空**，再判断是否匹配。
        
    3. 循环结束后，**栈必须为空**，才算完全匹配。
```cpp
先用哈希表，unordered_map<char,char> 记录匹配的括号, 键是右括号！

for(char c : s)
{
	if(pairs.count(c)){ //看c是不是键
		if(st.empty()||st.top()!=pairs[c]){return false;}//不匹配的情况
		st.pop();//否则就是匹配，那就把栈顶的左括号弹出
	}
	else{st.push(c);}//c是左括号话就直接进来
	

}


```


# [232. 用栈实现队列](https://leetcode.cn/problems/implement-queue-using-stacks/)


请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（`push`、`pop`、`peek`、`empty`）：

实现 `MyQueue` 类：

- `void push(int x)` 将元素 x 推到队列的末尾
- `int pop()` 从队列的开头移除并返回元素
- `int peek()` 返回队列开头的元素
- `boolean empty()` 如果队列为空，返回 `true` ；否则，返回 `false`

只有当“出口栈”为空时，才需要从“入口栈”导入数据!

```cpp
push就正常push到stack_in

int pop(val){
	if (stack_out.empty())
		{
		while(!stack_in.empty())
			{stack_out.push(stack_in.top());
			stack_in.pop();}
		}
	
	ans = stack_out.top();
	stack_out.pop();
	return ans
	
	}
peek只是pop方法倒腾完直接return top元素

```


# [739. 每日温度](https://leetcode.cn/problems/daily-temperatures/)

提示

给定一个整数数组 `temperatures` ，表示每天的温度，返回一个数组 `answer` ，其中 `answer[i]` 是指对于第 `i` 天，下一个更高温度出现在几天后。如果气温在这之后都不会升高，请在该位置用 `0` 来代替。

**示例 1:**

**输入:** `temperatures` = [73,74,75,71,69,72,76,73]
**输出:** [1,1,4,2,1,1,0,0]


```cpp
for(int i =0; i<temperatures.size();i++){
	int now_tpr = temperatures[i];
	
	while(!stack.empty()&&now_tpr>=temperatures[index])
	{   int index = stack.top();
		ans[index] = i - index; //一定注意我们stack记录的是index
		stack.pop();
	}
	stack.push(i); //无论如何都要入栈i，无论当前tpr是什么情况
}

```
