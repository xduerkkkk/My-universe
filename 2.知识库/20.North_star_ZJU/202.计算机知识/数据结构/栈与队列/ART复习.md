- **A - Abstract (抽象与建模):**
    
    1. **一句话描述本质：** 请用您自己的话，一句话概括“栈”的特性，并举一个生活中的例子。再用一句话概括“队列”的特性，并举一个例子。
        
    2. **实现的两种“载体”：** 栈和队列，既可以用“顺序表（数组）”实现，也可以用“链表”实现。请简单分析一下，这两种实现方式，各自的优缺点是什么？（提示：从空间大小的“固定/可变”，以及是否可能“溢出”的角度思考）
        
    3. **循环队列的“智慧”：** 为什么我们需要“循环队列”？它解决了顺序队列的什么问题？它又是通过“牺牲”什么，来解决“队空”和“队满”的判断难题的？

1. 栈的特性，先进后出的死胡同。队列，先来先出的，购物排队。
2. 数组空间大小固定，对程序员操作来说，比较简洁？但有可能溢出。链表实现的话，操作稍微复杂，空间不固定，不会益处。
3. 顺序队列，如果固定队头位置的话，队列变换时可能会造成搬运的计算消耗。
**它真正的问题，是“假溢出” (False Overflow)！** 循环队列，通过设置可变化的头尾指针来方便队列管理，最大程度利用空间。但仍会牺牲掉一个空间位置， 当头指针与尾指针是一个是 队空 当尾指针下一个元素是头指针是，队满。头指针这个位置，始终没有元素。



- **A - Abstract (抽象与建模):**
    
    1. **括号匹配：** while循环中，遇到右括号时，需要进行哪“三步”核心判断，才能保证逻辑的绝对严谨？
        
    2. **栈/队互转：** “用两个栈实现队列”和“用两个队列实现栈”，这两种模拟的“灵魂”是什么？都是通过“数据的一次（或多次）___”，来逆转数据结构的___特性。
        
    3. **最小栈：** “辅助栈”的使命，到底是“记录当前最小值”，还是“记录___的变迁史”？为什么前者行不通？
        
    4. **单调栈：** “单调栈”这个数据结构，是专门为了解决哪一类问题而设计的？它的while循环，在什么“时机”被触发？其“使命”又是什么？
        
    5. **逆波兰表达式：** 请复述这个算法的核心流程：“遇到___就入栈，遇到___就出栈计算再入栈”。计算时，操作数的顺序需要注意什么？


1. 检验top是否匹配，若匹配，pop出。右括号也不入栈。若不匹配，直接false了。 所以无论如何右括号都不入栈，无论如何左括号都是入栈的。
2. 模拟的灵魂，都是，数据的反转。 两个栈，能实现把一个栈的数据反转到另一个栈。队列也是。而反转这一过程，又能捕捉到模拟数据结构的特征，比如对两栈实现队列，栈反转后的最后一个数，恰好就是“队列”出队时的第一个数，于是pop一下stackout就模拟了队列出队
3. 辅助栈应是，记录历史最小值的变迁。如果栈内记录当前最小值的话，每次记录都会把栈清空。关键在于，我们的主栈，也会进行pop，pop后，数据变了，当前最小值就也变了。而辅助站如果每次只记录最优最小值，实际上还是记录了某一个状态。而丢失了历史状态的信息 。所以我们不应该每次清空栈，push进去就ok了。
4. 单调栈，为每一个元素找右边第一个比他大/小的数。 我们记录的是下标。我们维护的是单调栈，比如找右边第一个大数，就维护单调递减，如何有大数来了，为了保持单调递减状态我们就进行栈的pop，pop时，就能计算下标差从而达到题意。
5. 遇到数字入栈，遇到op出栈俩数字，计算出一个数字，入栈，先出的是op2
