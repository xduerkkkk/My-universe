**A - Abstract (抽象与建模):**

- **行动：** 不要看题目的具体内容，只看**标题**，比如“移动零”。
    
- **任务：** 闭上眼睛，强迫自己**主动回忆 (Active Recall)**：
    
    1. 这道题的核心矛盾/约束是什么？（原地、O(1)空间、保持相对顺序...）
        
    2. 它隶属于哪个“战术模型”？（“哦，这是‘同向双指针’里的‘原地划分’模型。”）
        
    3. 这个模型的“第一性原理”是什么？（“慢指针守住‘已处理好’的区域边界，快指针去探索未知区域，发现有效元素就把它丢给慢指针。”）
        
- **目的：** 这一步，是在训练您的大脑，建立从“问题表象”到“核心模型”的**高级索引**。如果想不起来，说明这个索引还很脆弱。
    

**R - Rebuild (重建与复现):**

- **行动：** 打开一个**空白**的编辑器。
    
- **任务：** **不参考**任何之前的代码，仅凭刚刚“A步骤”中回忆出的“战术模型”，将代码**从零开始，徒手复现**出来。
    
- **目的：** 这是对您“真理解”还是“假理解”的终极考验。如果您卡住了，那个卡住的点，就是您知识体系中最薄弱的“焊点”。这时再回头去看一眼标准答案，印象会无比深刻。
    

**T - Templatize (提炼与归档):**

- **行动：** 在您成功“重建”代码之后，立即开始**写题解，构建模板**。
    
- **任务：** 为这个“战术模型”（而不是这道题）建立一张专属的**“战术卡片”**。这张卡片就是您未来的“武器图纸”，必须包含：
    
    1. **模型名称：** 例如“同向双指针（原地划分模型）”。
        
    2. **适用场景（题眼识别器）：** 什么样特征的题目，应该立刻触发你对这个模型的联想？（例如：“数组”、“原地”、“移除/移动某种元素”、“保持相对顺序”...）
        
    3. **核心思想（C++伪代码或流程图）：** slow=0; for(fast=0...n) { if(fast满足条件) { nums[slow] = nums[fast]; slow++; } }
        
    4. **标准模板（C++代码）：** 锻造一份注释清晰、风格统一、可直接复用的代码模板。
        
    5. **关键细节/易错点：** 比如指针初始化的位置，循环的边界条件等。
        
    6. **典型例题链接：** 链接到“移动零”、“删除重复项”等题。