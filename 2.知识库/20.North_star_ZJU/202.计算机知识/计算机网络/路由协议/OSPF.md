**Open Shortest Path First**
**Link-State Advertisement**
**Link-State Database**

# 流程
## Hello协议
向周围的链路（不是路由器！是链路，理解为街道？） 发送‘Hello”问候包
这个问候能让他发现邻居并建立关系 ，所以这一步和rip的感觉一样的，就是和邻居亲密
## 构建LSA&LSDB
LSA是自己的报告，邻居是谁，去各个邻居的成本多少
LSDB是，以当前路由器为视角，他汇总所有的LSA，然后存储的数据库
这个数据库完全就是全网、全局拓扑地图。（全网，因为邻居传邻居，邻居再传邻居）
## 运行SPF算法
根据上一步的图，运算最短路径

# 解决问题
当有邻居宕机：
1. **全局地图同步更新**：通过这种“只转发、不加工”的泛洪机制，A的这份“坏消息”LSA，会以最快的速度，传遍整个网络区域。很快，**所有路由器**脑中的那张“全局地图”（LSDB），关于A的状态，都**同步更新**成了最新的、最准确的版本。
    
2. **各自重新计算**：每一台路由器，在更新完自己的LSDB后，都会**独立地、并行地**，在自己本地，以自己为根节点，**重新运行一次SPF (Dijkstra) 算法**。
    
3. **新路径诞生**：
    
    - B重新计算后发现，所有经过A去往其他地方的路径，成本都变了，它会立刻计算出新的、不经过A的最优路径。
        
    - C也一样，它会在自己本地，根据全新的、准确的地图，重新规划出自己的最佳路线。
        
4. **收敛完成**：这个过程非常快。因为“坏消息”是以“权威公告”的形式快速泛洪的，且路径计算是各路由器本地独立完成的，没有了RIP那种“无穷计数”的反复拉扯。整个网络的地图和路径，在极短的时间内，就恢复到了一个全新的、正确的、无环路的稳定状态。

