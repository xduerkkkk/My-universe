### **【高清版：TCP四次挥手作战图】**

**参与方：**
*   **主动关闭方 (Client)**：我们的主机（浏览器），在数据接收完毕后，决定关闭连接。
*   **被动关闭方 (Server)**：谷歌服务器，响应关闭请求。

**新登场的核心概念：**
*   **FIN (Finish)**: 一个“结束”标志位。FIN=1的包，是用来请求关闭连接的，与SYN一样，**不能携带数据**，但**要消耗一个序列号**。

---

### **第一步：[FIN] 客户端 -> 服务器**

**“我的话说完了，我这边准备关闭了。”**

1.  **客户端的动作**：浏览器发现所有数据都已加载完毕，于是通知操作系统关闭TCP连接。
2.  **报文段内容 (关键字段)**：
    *   **FIN = 1**：表明“这是一个连接关闭请求”。
    *   **ACK = 1**：（通常会捎带对服务器最后发来数据的确认）。
    *   **seq = u**：一个合适的序列号。（比如是客户端上一个数据包序列号的延续）
    *   **ack = v**：对服务器上一个数据包的确认。
3.  **发送**：客户端将这个`[FIN]`包发送给服务器。
4.  **状态变迁**：客户端的状态，从`ESTABLISHED`变为`FIN-WAIT-1`（等待对方的ACK）。

---

### **第二步：[ACK] 服务器 -> 客户端**

**“收到你的‘告别’请求。但我可能还有点数据没发完，请稍等。”**

1.  **服务器的动作**：服务器TCP模块收到`[FIN]`包。它立刻知道，客户端那边不会再有新的数据发过来了。
2.  **报文段内容 (关键字段)**：
    *   **FIN = 0**：我还没准备好关闭，所以FIN是0。
    *   **ACK = 1**：必须先确认收到了对方的“告别”。
    *   **seq = v**：使用自己的序列号。
    *   **ack = u + 1**：对客户端的`FIN`包进行确认。
3.  **发送**：服务器将这个`[ACK]`包发送给客户端。
4.  **状态变迁**：
    *   服务器的状态，变为`CLOSE-WAIT`（等待关闭）。此时，服务器仍然可以向客户端**发送数据**（如果还有没发完的）。
    *   客户端收到这个ACK后，状态从`FIN-WAIT-1`变为`FIN-WAIT-2`（等待服务器自己的FIN包）。

---

### **第三步：[FIN] 服务器 -> 客户端**

**“好了，我这边所有数据也发完了，我也准备关闭了。”**

1.  **服务器的动作**：服务器的应用层（Web服务器）确认所有响应数据都已发送完毕，通知TCP模块可以关闭连接了。
2.  **报文段内容 (关键字段)**：
    *   **FIN = 1**：我也要关闭连接了。
    *   **ACK = 1**：捎带确认信息。
    *   **seq = w**：一个新的序列号。（因为中间可能又发了数据）
    *   **ack = u + 1**：确认号保持不变。
3.  **发送**：服务器将这个`[FIN]`包发送给客户端。
4.  **状态变迁**：服务器的状态，从`CLOSE-WAIT`变为`LAST-ACK`（等待最后一个ACK）。

---

### **第四步：[ACK] 客户端 -> 服务器**

**“好的，收到你的‘告别’。再会！”**

1.  **客户端的动作**：客户端收到服务器的`[FIN]`包。
2.  **报文段内容 (关键字段)**：
    *   **FIN = 0**。
    *   **ACK = 1**。
    *   **seq = u + 1**。
    *   **ack = w + 1**：对服务器的`FIN`包进行最终确认。
3.  **发送**：客户端将这个最后的`[ACK]`包发送给服务器。
4.  **状态变迁**：
    *   服务器收到这个ACK后，连接**正式关闭**，释放所有资源。状态变为`CLOSED`。
    *   客户端发送完这个ACK后，它不会立刻关闭，而是会进入一个`TIME-WAIT`（时间等待）状态，等待**2*MSL**（两倍报文最大生存时间）后，才最终关闭。这是为了确保网络中可能存在的、迷路的最后一个ACK包能被正确处理，防止对后续的新连接产生干扰。

---