- **高层将领（应用层、传输层）** 负责制定“**战略**”：明确目标（HTTP请求），选择可靠的通信方式（TCP），并建立外交关系（三次握手）。
    
- **中层军官（网络层）** 负责绘制“**全球行军图**”：为我们的信件盖上跨国邮戳（IP地址），并规划出前往下一个中转站（默认网关）的路线。
    
- **基层士兵（数据链路层、物理层）** 负责执行“**战术**”：搞清楚下一个中转站的具体门牌号（ARP获取MAC地址），将信件打包成适合本地道路运输的包裹（封装成以太网帧），并最终以最基础的物理形式（电信号），将它送出军营。

想看谷歌的首页，得上网吧。
电脑连上网 ， 他需要知道这么几件事
- 我们设备的ip地址在哪
- 我的网关的ip在哪
- DNS服务器，就是那个把域名转化为ip的服务站在哪
值得注意的是，不关心mac地址。为啥？
<font color="#f79646">因为mac就是身份证，自己的mac不需要，而别人的mac是挺麻烦的。需要ARP</font>
<font color="#f79646">只在需要的时候，用专门的工具，解决专门的问题</font>

DHCP协议就是解决这几件事来了 DORA流程
- D：协议找设备
- O：offer，给设备分配ip（可能有多个，让设备选），另外，再告诉它网关、DNS服务器的地址
- Request: 设备确认其中一个ip，确认避免了IP地址资源的浪费。request是客户端发起的
- A：确认
额，request和accept感觉有点重复 ？
>Request 是**客户端**发起的、用于**终结竞争**的公开请求。Acknowledge 是**服务器**发起的、用于**完成签约**的最终确认。两者缺一不可。

现在，电脑连上网并拥有入网大礼包。
此时用户输入谷歌域名，我们需要转化为ip！
此时需要去DNS服务器。 首先dns服务器的ip发送到网关，网关其实也有很大概率还兼职dns服务器，如果确实是他，网关就直接进行查询了，查询域名对应ip。否则就去外面找dns服务器ip在哪，然后把这个域名丢给他。  
DNS协议的协议二字体现在哪？
>体现在查询和应答消息的严格格式规定。
>- **DNS查询报文**：就是一个严格按照格式打包的数据。里面包含了“报文ID”、“标志位（这是查询还是应答？）”、“问题数量”、“问题内容（我想查www.google.com的A记录）”等等。
 >   
>- **DNS应答报文**：也是一个严格按照格式打包的数据。里面包含了“报文ID”、“标志位”、“问题”、“答案数量”、“答案内容（www.google.com的A记录是142.251.42.78，有效期300秒）”等等。

以及，域名如何返回的？ 
DNS应答报文

<font color="#f79646">以及如何查找的，是有个表吗？</font>
<font color="#f79646">是的，一个巨大的表</font>
- **根服务器 (.):** 全球只有13组。它不存具体地址，只存一个“**顶级户籍管理员名录**”。它知道去哪里找管理 .com 的人，去哪里找管理 .cn 的人。
    
- **顶级域服务器 (.com)**: 它也不存具体地址，但它有一个“**授权户籍管理员名录**”。它知道去哪里找管理 google.com 的人，去哪里找管理 amazon.com 的人。
    
- **权威/授权服务器 (google.com)**: 这才是google.com这个“家族”真正的“**户籍管理员**”。它手里，才攥着那个最终的、包含了所有家族成员（如www, mail, docs）和其对应IP地址的**最终名册（Zone File）**。



转化为ip地址后， 要发送请求前往ip地址。
此时的问题是， 传输层，我们用什么传输方法？
我们用的TCP。而不是UDP。
TCP是需要不断确认，确认输出没问题接受没问题才传出，稳定。UDP是不管三七二十一，全部输出，实时性强  直播常用（这也是卡顿的原因）
TCP的稳定如何体现的？
首先，定义清楚客户端是想发起TCP的我们，服务端是我们想让他们接受的

**三次握手**：
- 客户端向服务端发送请求
- 服务端回应
- 客户端确认



这下，如何传输我们已经确定了。 
传输层，TCP，三次握手确定对方能接收， 然后把应用层的请求内容，客户端和服务端的端口、序列号和确认号...，包装成TCP报文段`[ TCP头[HTTP请求]`
传输层就管这么多了，传输层不是快递员！而是宏观调控传输的方法。 （这个时候是dns服务器请求之后了！）
我们就进入如何具体传送请求，叫网络层。
报文段只写了请求内容。 我们dns阶段查询的服务端ip还没在里面的。
接下来由**ip协议**完成，
他首先把客户端、服务端的ip都贴在TCP报文这个邮件上面。`[IP头[ TCP头[HTTP请求] ]`
其次 当IP协议拿到一个数据包时，它只会在自己的“路由表”（一张极简的地图）里查找：“根据这个目标IP，我下一跳该把包交给谁？”，
接下来按理说得进入网关，因为所有东西想出去都要经过网关。
但ip协议不是自己去网关的，是数据链路层去的，所以会给数据链路层通知一下网关ip。

那么视角来到数据链路层 
他现在 一只手提着 TCP报文段（包含TCP头和数据），被IP协议封装，在其**前面**加上IP头（包含源/目标IP），形成的IP数据报 ，即`[IP头[ TCP头[HTTP请求] ]`  一只手里拿着网关ip，去找网关mac地址。
<font color="#f79646">（为啥找mac地址？ ip地址为啥不够用？）</font>
<font color="#f79646">因为就是颗粒度不同，mac更细化 ip是很广泛的 定位大概位置的。</font>
<font color="#f79646">像连同一个wifi的手机电脑平板，对外的公网ip都一样！</font>
接着是ARP协议登场，他来辅助数据链路层这个快递小哥
询问网关ip `请问谁的IP地址是192.168.1.1？请告诉MAC地址是[你的MAC]`
网关会响应，
此时叫ARP响应告诉小哥他的mac地址
小哥还会缓存下，下次要寄给网关就方便了。

ok 这下数据就准备到网关
小哥会把新货物的前面贴上以太网头部这个信息，就是当前mac地址和下一节点mac地址（即网关）
整个货物长这样
`[以太网头[IP头[ TCP头[HTTP请求] ]以太网尾`

IP头的目标IP地址是谷歌服务器，所以这是网络层的（有谁？是ip协议），想去的地方。而以太网头的目标mac地址，只是下一步传输的地方。
<font color="#f79646">IP协议的核心工作，就是维护这个“最终目标IP”始终不变，并负责在每一跳（每一个路由器）决定“下一跳IP”是谁。而数据链路层，则负责根据IP协议的指令，找到“下一跳IP”对应的“下一跳MAC”</font>
这下彻底交给物理层 以电信号的方式 发送给网关（即路由器）。



首先，由路由器的数据链路层处理器拿到01信号。
接着 变为可查看的数据
首先查看以太网头部，看目标mac地址设备路由器mac。
不是就丢了，有人发错了。
是的话，就开始解析IP数据报了。
接着进入路由器的IP协议处理器部分。
1. 检查 ：看是否损坏、看最终目的地
2. 查询： 用很复杂的路由表，拿着目标ip在表里匹配。这里引申出路由表的一条信息，默认路由0.0.0.0 对于所有我在本地地图上找不到的、不认识的地址，一律将包裹发往我的上级——互联网服务提供商(ISP)的网关202.96.134.133，并且从我的‘广域网(WAN)’那个出口扔出去。
3. 转发：  比如上一步确定了，扔给上级网关。在把包扔出去之前，路由器还会对IP头部做一些小修改，比如将TTL（生存时间）字段减1，这是为了防止数据包在网络中无限循环


也就是，路由这也是有”IP协议“这一模块的，只不过对比第一次的IP协议，少了”把客户端、服务端的ip都贴在TCP报文这个邮件上面“这一动作。 然后下一跳ip知道了 又要交给数据链路层了， 又要用 ARP协议为数据链路层小哥寻找mac地址了。 然后又封装以太网帧，送出去。

就这样一次又一次的经过...路由？


最终到达服务器。
**物理层**：服务器的网卡接收到最后一跳传来的电信号/光信号，将其翻译成比特流，还原成一个**以太网帧**。
    
2. **数据链路层**：
    
    - **检查“本地快递单”**：它查看以太网头部，读取**目标MAC地址**，与自己的MAC地址比对。确认无误，这是送给我的！
        
    - **拆开第一层包装**：它撕掉以太网的头部和尾部，取出了里面的“货物”——**IP数据报**。
        
    - **任务完成**：数据链路层的使命到此结束。它将IP数据报，上交给服务器的网络层处理。

网络层：
与路由器相同
仍然查看ip数据包的ip头
但此刻，他发现目标ip竟然就是自己。
ok 接下来与之前路由器不同了！
既然是自己，那我就心安理得地拆包裹了！
现在，务器手中剩下的，是那个从我们主机传输层出发、一路“不忘初心”的——**TCP报文段**

**传输层**：服务器的TCP协议模块接手TCP报文段。
    
- **检查“部门信封”**：它开始查看**TCP头部**。
	
- **送到哪个部门？**：它看到了至关重要的**目标端口号：443**。服务器的操作系统一看：“哦！443端口，这是我们的‘Web服务部门(HTTPS)’正在监听的端口！”
	
- **进行可靠性检查**：TCP模块还会检查序列号等信息，确保这个数据包是按顺序到达的、没有损坏的。如果一切正常，它会准备一个**ACK确认包**，排队等待发回给我们的主机，告诉我们：“你发的这个包，我收到了！”  
	
- **拆开第三层包装**：确认无误后，TCP模块撕掉了TCP头部，取出了最最核心的“货物”。

终于，在经历了千山万水的旅行之后，我们最初的那份“订单”，那段纯粹的、未经任何修改的**HTTP请求数据**，被完整地取了出来！

**应用层**: 理解http请求。

接着就是应用层回应请求，然后数据返程！

应用层的html代码，在返程前需要
- 分段：将长长的html代码，切成一个个大小合适的数据段
- 封装：每一个数据段都封装成TCP报文段
然后仍然是经过一个个路由，一次次数据链路 和物理层
和来的时候一样。
问题是两个
- 有其中一个包丢失怎么办
我们的电脑，每次成功接收到包后，会发送ACK确认包给服务器。如果服务器迟迟没等到确认包，就从发件箱缓存里找出对应的包，再发一次
- 发的包裹顺序错了怎么办
TCP模块有收件缓冲区，他会把顺序排好，确认好了，再全部递交给应用层。有缺的顺序，等就是了。


最后是渲染，这个跟计网没关了感觉，不说了 



