# 主存储器
## 主存基本结构
## 数据存放
- 地址访问模式
- 大端和小端方式
**大端模式（Big-Endian）​**​  
​**高位字节存放在低地址**，符合人类阅读习惯。  
_示例_：32位整数0x12345678在内存中的布局（地址递增方向）：

复制

```markdown
地址： 0x1000 0x1001 0x1002 0x1003
数据：   12     34     56     78
```
## 半导体存储器
### sram，dram
1. 存储元  -存储单位-存储器
2. 
我讲一下我理解的sram和dram数据流，。sram芯片会有许多数据线连接，这些线是很多是从译码器那边传过来的。cpu以地址线发送给译码器，译码器翻译。有专门翻译行的，有专门翻译列的，**行地址**和**列地址**可能由地址线的高位和低位拆分得到（如16位地址中，高8位为行地址，低8位为列地址），译码器分别激活对应的行选通线和列选通线，最终定位到具体的存储单元最终就能定位到sram芯片里的具体格子。当然，还有线决定着读操作还是写操作。dram和sram的区别只是，它有复用的线，又传行信息又传列信息。再就是便宜，比sram慢。<font color="#e36c09">还有 dram 需动态刷新</font>最后，他们读到格子里面的内容（0或1）后，通过数据线返还给cpu？


你的理解在框架上正确，但需补充以下关键点：

1. SRAM和DRAM的存储单元结构差异（6T vs 1T1C）。
2. DRAM的地址复用具体实现（分时传输行/列地址）。
3. 数据保持机制（SRAM静态 vs DRAM动态刷新）。
4. 速度差异的核心原因（SRAM无刷新延迟，DRAM需行缓冲和刷新）

### **通俗解释：译码器与总线系统的层次结构**

### **1. 译码器的位置**

译码器可以存在于**芯片内部**和**芯片外部**，具体取决于功能需求：

- **芯片内部译码器**： 例如，存储芯片（如内存条上的DRAM芯片）内部集成译码器，用于解析地址总线中的**低位地址**，定位芯片内的具体存储单元（如选择某一行、某一列） 
    

    。 **类比**：仓库管理员根据地址的“门牌号”找到具体货架。
- **芯片外部译码器**： 例如，74LS138这类独立芯片，用于解析地址总线中的**高位地址**，生成片选信号（CS），选择要操作的存储芯片或外设 

    。 **类比**：快递分拣中心根据地址的“城市名”决定包裹送到哪个仓库。

### **2. 总线与芯片的层次结构**

计算机中地址总线、数据总线、译码器和芯片的协作流程如下：

1. **CPU发送地址**：
    
    - CPU通过**地址总线**发送完整的地址（如32位地址），其中：
        - **高位地址**（如A13~A31）：送给外部译码器，确定操作哪个芯片。
        - **低位地址**（如A0~A12）：直接送给存储芯片，定位芯片内部的存储单元 


            。
    - **控制总线**（如读写信号WE）告诉芯片是读还是写。
2. **译码器的作用**：
    
    - 外部译码器（如74LS138）将高位地址转换为片选信号（如Y0~Y7），激活目标芯片 
        

        。
    - 内部译码器（芯片自带）将低位地址转换为行/列选通信号，定位具体存储单元 
        

        。
3. **数据传输**：
    
    - **数据总线**负责在CPU和被选中的芯片之间传输数据：
        - 读操作：数据从芯片→CPU。
        - 写操作：数据从CPU→芯片 


### **3. 通俗类比：快递分拣系统**

- **地址总线**：快递单上的完整地址（如“北京市海淀区中关村大街1号”）。
- **外部译码器**：分拣中心根据“北京市”决定包裹送到北京仓库。
- **内部译码器**：北京仓库管理员根据“海淀区中关村大街1号”找到具体货架。
- **数据总线**：包裹内容（数据）通过卡车（数据总线）运输。
- **控制总线**：分拣指令（如“取件”或“派送”）。

### **4. 关键总结**

|**组件**|**功能**|**层级**|
|---|---|---|
|**地址总线**|传输完整地址（高位+低位）|全局传输通道|
|**外部译码器**|解析高位地址，选择目标芯片（如选仓库）|芯片外部|
|**存储芯片**|内部译码器解析低位地址，定位存储单元|芯片内部|
|**数据总线**|传输实际数据（如货物）|全局传输通道|
|**控制总线**|发送读/写等指令（如取件/派送）|全局控制信号|





具体实现是这样，cache 除了块这个概念，还有“有效位”这个概念，它用来标记这块地方是否有数据。若 cache 采用直接映射法，那么主存的某一批地址大家族，只能在 cache 固定的块，cpu 要读一个数据，先根据地址高位线确定块，然后直接定位到 cache 块的位置，一定要么发现这里是空的，要么发现这里是有想要的数据。如果采用全相联映射法，cpu 读数据时，需要从第一个块的块内地址读起，不断比较，如果要从主存传入信息，也是从头到尾不断看标记位看是否空，空了就直接写入。这样空间效率高，但比较次数多。还有一个方法就是映射与固定和仪器
4

