# 知识点
存储管理 分区
覆盖 （一个程序段内）交换技术（不同段间）
单一连续 最先适应算法 最佳最坏适应
地址变换过程
页 段 虚拟内存管理（重点），读各种格式地址 。页表  变换过程算地址。优缺点  考计算
虚拟内存，为什么要 程序局部性原理。怎么实现，请求段页式（解释）。 缺页中断。 淘汰算法（必考）。
内存扩充（虚拟内存）
进程 存储 一体




## 冯诺依曼

大致理解：冯诺依曼体系，以存储器为中心。此时效率更高效也更清晰了，软件读入的数据直接存储到“存储器”，控制器读取存储器的数据，这个数据包括数据（各种各样数字）和指令（加减乘除），其中“指令”包括操作码和要处理数据的地址码。控制器解码，读懂了数据，接下来交给运算器，运算器让硬件响应，执行计算。其中，“存储器、控制器、运算器” 称为主机，控制器+运算器就是 cpu

![](../../../../../assets/image/期末应试-1764335646700.jpeg)

## 地址重定位 
程序里面有各种地址，但都是虚拟地址，方便程序员读的。 MMU，需要把虚拟地址转化为内存真实存在的物理地址。这一过程叫地址重定位 
- 绝对装入 没看懂，是说，干脆设计地址的时候 虚拟地址/逻辑地址（这俩个描述有区别吗） 就设计的和物理地址一样？
**对，根本就没有“地址转换”这个过程，也没有MMU的事。**
- 可重定位装入/ 静态重定位 程序执行之前，额，在装入内存之前   一一对应 把物理地址找出来 ？  
程序要运行了，操作系统决定把它放在物理内存的 10000 号位置。 在把程序搬进内存的一瞬间，把程序里所有的指令地址都加上 10000。一旦装入，程序就焊死在那了。如果内存不够，想把它挪个窝？不行，因为指令里的地址已经写死了。
- 动态再定位 逻辑地址装入内存时保持原样 需要 实实在在访问物理内存时，再找物理地址
**完全正确。**  **内存里的指令完全不改**  **只需要重定位寄存器**
### 1. 绝对装入 (Absolute Loading)

> **你的理解**：干脆设计地址的时候，逻辑地址就设计得和物理地址一样？  
> **判决**：**对了一半，但因果关系反了。**

- **纠正**：不是“逻辑地址设计得像物理地址”，而是**编译器直接生成物理地址**。
    
- **场景**：单道程序环境（比如单片机、无操作系统的微波炉、极其古老的DOS）。
    
- **逻辑链条**：
    
    1. 程序员写代码。
        
    2. 编译器知道这个程序将来**一定**会放在内存的 1000 号单元（因为内存里只有它一个程序，或者它是操作系统内核）。
        
    3. 编译器直接把代码里的跳转指令写成 JMP 1000。
        
    4. **根本就没有“地址转换”这个过程**，也没有MMU的事。
        
- **缺点**：灵活性为0。内存换个地方就跑不起来。
    

---

### 2. 可重定位装入 (Static Relocation / 静态重定位)

> **你的理解**：在装入内存之前，一一对应把物理地址找出来？  
> **判决**：**描述太模糊，容易丢分。**

- **关键词**：**装入时 (Load Time)**、**一次性**。
    
- **怎么做**：
    
    1. 编译器生成的依然是逻辑地址（从0开始）。
        
    2. 程序要运行了，操作系统决定把它放在物理内存的 10000 号位置。
        
    3. **装入程序（Loader）** 在把程序搬进内存的一瞬间，把程序里所有的指令地址都加上 10000。
        
    4. 原来的 JMP 10 变成了 JMP 10010。
        
    5. **重点**：一旦放进去，**数据在内存里的样子就已经变了**（逻辑地址变成了物理地址）。
        
- **致命缺陷（考试常考）**：
    
    - **不能移动**：一旦装入，程序就焊死在那了。如果内存不够，想把它挪个窝？不行，因为指令里的地址已经写死了。
        
    - **无法申请内存空间**：程序运行期间不能动态申请内存。
        

---

### 3. 动态重定位 (Dynamic Relocation) —— **现代OS的核心**

> **你的理解**：逻辑地址装入内存时保持原样，访问物理内存时，再找物理地址。  
> **判决**：**完全正确。**

- **关键词**：**运行时 (Run Time)**、**硬件支持 (MMU/重定位寄存器)**。
    
- **怎么做**：
    
    1. 程序装入内存，放在 10000 号位置。
        
    2. **内存里的指令完全不改**，依然是 JMP 10。
        
    3. 操作系统在CPU里设置一个**重定位寄存器**，值为 10000。
        
    4. 每次CPU执行指令要访问地址 10 时，硬件电路（MMU）自动进行计算：10 + 10000 = 10010，然后去访问物理内存。
        
- **核心优势（必考）**：
    
    - **可以移动**：要把程序挪到 20000？只需要改一下寄存器的值就行，不用改程序代码。
        
    - **紧凑（Compaction）**：内存碎片太多时，可以把程序拢一拢，腾出大块空间（基于“移动”能力）。
        
    - **虚拟内存的基础**：只有动态重定位，才能实现把程序切碎了（分页）或者只装入一部分（虚拟存储）。

## 内存扩充
### 覆盖技术
