# 知识点
存储管理 分区
覆盖 （一个程序段内）交换技术（不同段间）

单一连续 最先适应算法 最佳最坏适应
地址变换过程
页 段 虚拟内存管理（重点），读各种格式地址 。页表  变换过程算地址。优缺点  考计算
虚拟内存，为什么要 程序局部性原理。怎么实现，请求段页式（解释）。 缺页中断。 淘汰算法（必考）。
内存扩充（虚拟内存）
进程 存储 一体




## 冯诺依曼

大致理解：冯诺依曼体系，以存储器为中心。此时效率更高效也更清晰了，软件读入的数据直接存储到“存储器”，控制器读取存储器的数据，这个数据包括数据（各种各样数字）和指令（加减乘除），其中“指令”包括操作码和要处理数据的地址码。控制器解码，读懂了数据，接下来交给运算器，运算器让硬件响应，执行计算。其中，“存储器、控制器、运算器” 称为主机，控制器+运算器就是 cpu

![](../../../../../assets/image/期末应试-1764335646700.jpeg)

## 地址重定位 
程序里面有各种地址，但都是虚拟地址，方便程序员读的。 MMU，需要把虚拟地址转化为内存真实存在的物理地址。这一过程叫地址重定位 
- 绝对装入 没看懂，是说，干脆设计地址的时候 虚拟地址/逻辑地址（这俩个描述有区别吗） 就设计的和物理地址一样？
**对，根本就没有“地址转换”这个过程，也没有MMU的事。**
- 可重定位装入/ 静态重定位 程序执行之前，额，在装入内存之前   一一对应 把物理地址找出来 ？  
程序要运行了，操作系统决定把它放在物理内存的 10000 号位置。 在把程序搬进内存的一瞬间，把程序里所有的指令地址都加上 10000。一旦装入，程序就焊死在那了。如果内存不够，想把它挪个窝？不行，因为指令里的地址已经写死了。
- 动态再定位 逻辑地址装入内存时保持原样 需要 实实在在访问物理内存时，再找物理地址
**完全正确。**  **内存里的指令完全不改**  **只需要重定位寄存器**
### 1. 绝对装入 (Absolute Loading)

> **你的理解**：干脆设计地址的时候，逻辑地址就设计得和物理地址一样？  
> **判决**：**对了一半，但因果关系反了。**

- **纠正**：不是“逻辑地址设计得像物理地址”，而是**编译器直接生成物理地址**。
    
- **场景**：单道程序环境（比如单片机、无操作系统的微波炉、极其古老的DOS）。
    
- **逻辑链条**：
    
    1. 程序员写代码。
        
    2. 编译器知道这个程序将来**一定**会放在内存的 1000 号单元（因为内存里只有它一个程序，或者它是操作系统内核）。
        
    3. 编译器直接把代码里的跳转指令写成 JMP 1000。
        
    4. **根本就没有“地址转换”这个过程**，也没有MMU的事。
        
- **缺点**：灵活性为0。内存换个地方就跑不起来。
    

---

### 2. 可重定位装入 (Static Relocation / 静态重定位)

> **你的理解**：在装入内存之前，一一对应把物理地址找出来？  
> **判决**：**描述太模糊，容易丢分。**

- **关键词**：**装入时 (Load Time)**、**一次性**。
    
- **怎么做**：
    
    1. 编译器生成的依然是逻辑地址（从0开始）。
        
    2. 程序要运行了，操作系统决定把它放在物理内存的 10000 号位置。
        
    3. **装入程序（Loader）** 在把程序搬进内存的一瞬间，把程序里所有的指令地址都加上 10000。
        
    4. 原来的 JMP 10 变成了 JMP 10010。
        
    5. **重点**：一旦放进去，**数据在内存里的样子就已经变了**（逻辑地址变成了物理地址）。
        
- **致命缺陷（考试常考）**：
    
    - **不能移动**：一旦装入，程序就焊死在那了。如果内存不够，想把它挪个窝？不行，因为指令里的地址已经写死了。
        
    - **无法申请内存空间**：程序运行期间不能动态申请内存。
        

---

### 3. 动态重定位 (Dynamic Relocation) —— **现代OS的核心**

> **你的理解**：逻辑地址装入内存时保持原样，访问物理内存时，再找物理地址。  
> **判决**：**完全正确。**

- **关键词**：**运行时 (Run Time)**、**硬件支持 (MMU/重定位寄存器)**。
    
- **怎么做**：
    
    1. 程序装入内存，放在 10000 号位置。
        
    2. **内存里的指令完全不改**，依然是 JMP 10。
        
    3. 操作系统在CPU里设置一个**重定位寄存器**，值为 10000。
        
    4. 每次CPU执行指令要访问地址 10 时，硬件电路（MMU）自动进行计算：10 + 10000 = 10010，然后去访问物理内存。
        
- **核心优势（必考）**：
    
    - **可以移动**：要把程序挪到 20000？只需要改一下寄存器的值就行，不用改程序代码。
        
    - **紧凑（Compaction）**：内存碎片太多时，可以把程序拢一拢，腾出大块空间（基于“移动”能力）。
        
    - **虚拟内存的基础**：只有动态重定位，才能实现把程序切碎了（分页）或者只装入一部分（虚拟存储）。

## 内存扩充
### 覆盖技术
没搞懂啊 在说啥呢 
若图中的 **B** 和 **C** 是兄弟关系（由A选择调用B或者C）。**如果运行B，就绝不会运行C；如果运行C，就绝不会运行B。**B (50K) 和 C (30K) 互斥。既然不同时用，那就划出一块地盘，**谁大听谁的**。B大，所以划出50K。
- -如果你要用B，就把B装进去。
        
- 如果你后来要用C，就把B**踢走**（覆盖掉），把C装进**同一块内存地址**。
- **覆盖区 1（下面）**：F, D, E 也是互斥的。F(30), D(20), E(40)。E最大，所以划出40K的空间。
![](../../../../../assets/image/期末应试-1764503615085.jpeg)
### 交换技术
![](../../../../../assets/image/期末应试-1764503659302.jpeg)
啥叫作业？
在操作系统这门课里，看到“作业”，你就把它当成**“进程 (Process)”**或者**“正在运行的程序”**
- 内存里有 Job1, Job2, Job3。
- 突然，内存不够了，或者 Job4 想进来但没地儿了。
- 操作系统看 Job2 不顺眼（比如它优先级低，或者正在睡觉等待IO）。
- **动作**：把 Job2 整个儿打包，**踢出内存**，扔到**外存（磁盘/硬盘）** 的交换区（Backing Store）。
- **后果**：内存空出来一块，Job4 可以进来了。
- **后续**：等 Job2 醒了或者轮到它了，再把它从磁盘**接回来**。


![](../../../../../assets/image/期末应试-1764503665838.jpeg)
## 内存分配与回收
-  单一连续分区
啥意思？？整个内存，只能装一个用户程序？？ 举个例子 内存16gb 一个程序3mb  那也是这个瞬间 内存只有这3mb？
- 固定分区
就是你有多大就给你分配多大呗 不对我看到这缺点是存在内碎片，那么缺点应该是，最开始就把分区固定好。只不过有不一样大小。有20kb的区域 有60kb的... 如果15kb的进程，他就独占20kb的。显然，会有内存碎片 
- 可变分区
	你有多大就给你分配多大  感觉这个就很无敌啊？
	- 最先适应算法：从头查找空闲分区。释放方法相邻合并，否则插入。
	- 下次适应算法：从上次分配的分区起查找 到最后的分区了就回到开头
	- 最佳适应算法：以空白区的大小排序，从小到大开始找。释放方法，在链表搜索地址相邻的空闲区，合并后再插入到合适的地方？什么意思？这么好的方法为什么前俩个不用
	- 最坏适应算法：与上面相反，递减顺序

诶，内存扩充和内存分配与回收，都讲的是”分区“法吗

## 虚拟地址地址变换过程
比如LOAD A 31