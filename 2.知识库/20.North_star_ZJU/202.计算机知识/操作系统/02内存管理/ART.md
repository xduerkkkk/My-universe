**1. 什么是“缺页中断 (Page Fault)”？请简要描述操作系统处理一次缺页中断的大致流程。**  
(提示：回想那个“房间尚未建造，请联系物业”的故事，以及物业接到投诉后的处理步骤。)

当我们使用虚拟内存机制时，我们是以页框为物理单位，以页为虚拟单位”进行存储“的。我们会给程序员说，你有一堆页可用。但实际上，不一定有对应够的页框，这只是个承诺。但是当真的，程序员要访问页的时候，发现根本没和页框对应上，此时就叫缺页中断，于是再现场对应个页框，或页框用完了，先找一个倒霉蛋（用某种算法找), 将其数据先放到遥远的硬盘，现场空出来个页框，然后把我们需要的东西写入页框，再重新把我们的页和此页框对应。这就是缺页中断的流程。

**2. 什么是“Belady异常”？为什么像LRU这样的算法不会出现这种异常？**  
(提示：它的反直觉之处在哪？LRU算法的核心指导思想是什么？)

对于缺页中断，找倒霉蛋算法，如果用FIFO，不考虑访问模式，有可能性能非常差，会频繁缺页。即使最初，承诺的空间很大，也不行。而LRU就考虑访问了，访问的多的，我不换你，访问的少的，你当倒霉蛋。考虑访问，才能和”缺页替换“联系在一起
**3. 什么是“颠簸 (Thrashing)”？它产生的主要原因是什么？**  
(提示：回想一下“天天都在搬家，没人能安心生活”的小区灾难，以及住户的什么关键需求没有被满足？)
颠簸就是 频繁缺页吧？  那就是程序员每次访问都要经历 用硬盘把别人的数据存储， 用硬盘把自己的数据放到页框， 然后建立页与页框联系这过程，效率低


**4. 什么是“内存映射文件 (mmap)”？相比传统的read/write文件读写，它最大的优势是什么？**  
(提示：回想那个处理100GB视频文件的剪辑师，mmap是如何把“文件I/O”伪装成“内存访问”的？)
我的理解是，  其实这个就是缺页处理。 完全一样吧？ 我们把文件就当作我们需要的数据，然后仍然是MMU承诺给我们100gb空地，实则不然。 我们需要的时候，他再去找，缺页了再去硬盘找，然后页和页框对应。   一模一样。  传统io就是一直访问硬盘，现在我们把这个弄成和虚拟内存管理一样