- **逻辑地址 (Logical Address)** / **虚拟地址 (Virtual Address)**
    
    - **定义**：由**CPU生成**的、在程序代码中使用的地址。它不对应任何真实的物理内存位置。
        
    - **形式**：在32位系统上，它就是一个0到 2^32-1 之间的数字。
        
    - **谁使用**：**程序员**和**编译器**只和逻辑地址打交道。你写的 int* p = &a;，这里的 p 存放的就是一个逻辑地址。
        
- **物理地址 (Physical Address)**
    
    - **定义**：在**物理内存芯片上**，用于唯一标识一个**内存单元（通常是一个字节）**的真实地址。
        
    - **形式**：如果你的电脑有4GB内存，它就是一个0到 2^32-1 之间的数字，对应着内存条上的每一个存储单元。
        
    - **谁使用**：只有**内存控制器 (Memory Controller)** 和**操作系统内核**的底层代码，才会直接和物理地址打交道。
        
- **地址变换 (Address Translation)**
    
    - **定义**：将一个**逻辑地址**，转换为其对应的**物理地址**的过程。
        
    - **谁负责**：这个过程，是由一个专门的**硬件**——**内存管理单元 (Memory Management Unit, MMU)**——来完成的。
        
    - **依据**：MMU进行变换的依据，是一张由**操作系统**负责维护的**“映射表”**。这张表的具体实现，就是我们即将学习的**“页表 (Page Table)”**或**“段表 (Segment Table)”**。
        
    - **时机**：这个变换，发生在**CPU执行每一条需要访问内存的指令时**。比如 MOV EAX, [0x1234]，CPU在把逻辑地址 0x1234 发送到内存总线**之前**，会先把它交给MMU，MMU把它翻译成一个物理地址（比如 0x8888），然后CPU再用 0x8888 去访问物理内存。
        

---
- **连续分配 (Contiguous Allocation)**：
    
    - **定义**：一种内存分配策略，要求为每个进程分配**一块地址连续**的物理内存区域。
        
    - **实现**：操作系统通过维护一张**内存空闲分区表/链表**来跟踪可用内存。
        
- **动态分区分配算法 (Dynamic Storage-Allocation Algorithms)**：
    
    - **First-Fit**：从头开始搜索空闲链表，选择第一个足够大的分区。
        
    - **Best-Fit**：搜索整个链表，选择一个大小与请求最接近且足够大的分区。
        
    - **Worst-Fit**：搜索整个链表，选择最大的那个分区。
        
    - **权衡**：First-Fit速度最快；Best-Fit产生的碎片最小，但搜索慢；Worst-Fit试图保留大的空闲块，但实际效果往往不佳。
        
- **碎片 (Fragmentation)**：
    
    - **外部碎片 (External Fragmentation)**：存在足够的**总空闲内存**来满足一个请求，但这些空闲内存**不是连续的**。这是**连续分配**策略的**致命缺陷**。
        
    - **内部碎片 (Internal Fragmentation)**：当分配给进程的内存块，比进程实际需要的大小时，多出来的那一小部分**在该块内部**无法被利用的内存。我们后面学的“分页”会产生这个问题。
        
- **紧缩 (Compaction)**：
    
    - **定义**：移动内存中已分配的进程，使它们都连续排列，从而将所有小的空闲块合并成一个大的空闲块。
        
    - **要求**：必须是**动态重定位**。即程序运行期间，其在内存中的物理地址是可以改变的。这需要硬件（如基址/限长寄存器）的支持。
        
    - **代价**：开销巨大，通常只在系统负载很低或有特殊需求时才会执行。
        

---

诶，这就是虚拟内存的定义嘛 就是 实际上 这个”房子“的地皮就是不连续的， 很多小地皮的 这样， 所有空间都能被利用起来。核心就是”连续“这个要求没有了。 毕竟外部碎片的原因就是这个”连续“的要求。 不过，对于程序员来说，我们要以为，或认为，他们是连续的。 所以就是内存管理单元维护页表来实现我们觉得连续 实际不连续碎片化。 这也的话 我们就记 张三家，占了多少个”小地皮“，我们的单位就是这个小地皮了，而不是平方米。 （不过小地皮足够小，也能变成1个存储单元，但我们不会这样用） 哦，也要记录起始的那块地皮位置吧？ 剩下的用链表串起来？也就是记录头节点？ 不对，好像也不用？ 是不是要把每个小地皮的位置记录下？