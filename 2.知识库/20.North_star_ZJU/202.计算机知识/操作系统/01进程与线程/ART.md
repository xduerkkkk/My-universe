# Abstract

### 进程

**进程是操作系统为了在一个混乱的、共享的硬件上，能够『安全地』、『并发地』运行多个程序而发明的一个『抽象概念』。它的核心是『隔离』，通过为每个程序创建独立的『资源边界』（如内存空间、文件句柄），来达成两个关键目标：**  
**1. 保护 (Protection)：防止一个程序的错误或恶意行为，破坏其他程序乃至整个系统的稳定。**  
**2. 调度 (Scheduling)：为操作系统提供一个可以进行资源『公平』分配和调度的基本单位。”**

## 调度

**“调度是操作系统为了解决『CPU资源』的极端稀缺性（僧多粥少）与『人类感知』的有限性之间矛盾的一系列策略。它的本质是在『微观的串行』基础上，通过在极短的时间内进行高速的『任务切换』，来为用户创造一个『所有程序都在同时运行』的宏观假象。其最终目标，不是为了绝对的公平或效率，而是为了在『响应速度』、『吞吐量』和『公平性』这几个相互冲突的指标之间，达成一种符合用户期望的、动态的『平衡』。”**

## 线程

**线程是在『进程』这个实现了『安全隔离』的重型容器内部，为了追求『极致效率』而设计的『轻量级执行流』。它的本质，是对进程所拥有的资源进行『分时复用』，从而在两个关键维度上获得性能的巨大提升：**

**1. 降低并发的『调度开销』：通过共享地址空间，使得线程间的上下文切换，避免了进程切换所带来的昂贵的缓存与TLB失效。**  
**2. 降低并发的『通信开销』：通过共享内存，使得线程间的通信几乎是零成本的，避免了复杂的IPC机制。**

**因此，线程的诞生，本身就是一次经典的架构权衡：我们牺牲了完美的『隔离性』（一个线程的崩溃可能导致整个进程崩溃），以此换取了在紧密协作型任务中，无与伦比的『性能』。”**

## 锁

回想一下：  
if (is_locked == 0) // 检查  
// <--- “坏东西”在这里出现！  
is_locked = 1; // 设置

在“检查”和“设置”之间，那个能幽灵般插入进来的“坏东西”，就是**“并发 (Concurrency)”**本身，或者说，是由并发所导致的**“非原子性 (Non-atomicity)”**。

锁的敌人，就是**“一个逻辑上连续的操作（比如‘检查并设置’），在执行层面却可以被中途打断”** 这个残酷的现实。

### **抽象总结：“锁”的第一性原理**

现在，我们把这三点拼起来，就能得到一个对“锁”的、极其深刻的抽象定义：

**“锁是一种『同步原语』，它诞生的唯一目的，是为了对抗并发环境下的『非原子性』这一根本性难题。它通过依赖『硬件原子指令』所提供的、不可分割的微观能力，来构建一个宏观的『临界区』，从而在一段指定的代码逻辑中，强制实现『互斥』。**

**然而，锁的本质，是在一个并行系统中，人为地引入一个『串行点』。因此，使用锁，就是在用『并行度』的损失，去换取『数据一致性』的保证。如何设计锁的粒度、减少锁的持有时间，是所有并发编程的核心挑战，因为它直接决定了程序在多核时代下的性能天花板。”**






# Rebuild

**“你点击了Word图标，写下一行字‘Hello, OS’，然后按下‘保存’按钮。在这短短几秒内，操作系统内核为你做了什么？”**

这个故事，几乎能完美地串联起我们学过的所有核心概念：

- **点击图标** -> **进程的创建** (fork, exec)
    
- **Word运行起来，同时还能响应你的鼠标移动** -> **CPU调度** (时间片轮转, 多级反馈队列)
    
- **Word内部，“打字线程”和“拼写检查线程”在同时工作** -> **线程** (用户级/内核级), **进程内通信**
    
- **这两个线程都需要访问同一份文档数据** -> **同步与互斥** (锁, 信号量, 管程)
    
- **你按下“保存”，Word需要和文件系统驱动（另一个进程）交互** -> **进程间通信 (IPC)** (管道, 消息队列)
    
- **如果Word和杀毒软件同时要扫描同一个文件** -> **死锁** (成因与处理策略)



安静的桌面。你的鼠标指针，精准地悬停在那个蓝色的 "W" 图标上。你的手指坚定地按下，清脆的“咔哒”声响了两下。就在这电光火石之间，你的这个“双击”动作，被鼠标驱动程序捕捉，并转化为了一个发给操作系统GUI窗口管理器的**“事件 (Event)”**。窗口管理器识别出，这个事件的目标是启动一个新程序——Word.exe。

于是，它向我们故事的第一个主角——**“操作系统内核”**——发出了一个请求：“陛下，请为我执行这个程序！”

内核收到请求，大戏正式开演。它要做的第一件事，就是为即将诞生的Word程序，准备一个家。

首先，内核创建“进程”这个概念，他把即将运行的word程序，称为一个进程。
由此，才能享受操作系统内核的“保护”和“调度”，确保Word城堡里就算发生火灾，也不会殃及旁边的Chrome城堡。
整个进程，内核给他分配了代码放的地方、数据放的地方，还有进程的地址、进程的状态。‘

进程准备好了，要去运行具体的代码！
但是，还有很多个和他相同的进程呢！
他们都在等待，等待何时轮到自己去cpu的聚光灯舞台。

而挑选下一个来cpu舞台的，就叫cpu调度器。

调度器如何选择调度方法？
最简单的，是FCFS，按顺序服务。公平、简单！但每个进程响应时间不同，如果响应超短的进程排在了响应超长的进程后，那超短进程哭死！
那有一个听起来也公平，让用户体感更好的方法，时间片轮转。
其实就是一段时间完了，调度器重新选择下一个进程。这样，每个进程都能很快上舞台，只不过每个人时间有限罢了。

听起来时间片比FCFS好。
我们还可以再次升级时间片轮转算法，
升级为多级队列反馈算法！
首先，我们命名一下在时间片轮转算法下各进程的状态。
- 在cpu聚光灯下的，应为“运行态”。
- 准备好，想要进入聚光灯的，应为“就绪态”
- 在cpu聚光灯下时，发现自己必须要忙其他的活才能再过来，应为“堵塞态” 。等待事情完成后， 变成就绪态
那我们介绍一下多级反馈队列，这里的队列指的就是“就绪态”排队的队列。
Q1Q2Q3代表优先级，Q1优先级最高。
无论什么就绪态，都暂时放到Q1.
我们要对他进行“测试”：
我们会给Q1的进程很短的时间片，如果很短的时间片内，真的完成了，就说明，他值得Q1，因为不占用时间，我们很快就能给用户反馈。
如果完成不了，甚至还有很多，我们把它降级到Q2Q3的低优先级队列。因为完成不了说明耗费时间，是计算密集型，我们给他们很长的时间片！
然后宏观来看，就快速把Q1处理完，然后处理Q2Q3.
Q2Q3咋抉择，一样的，如果进程在Q2的时间片用完了还没结束进程，说明Q2还不够，退到Q3，Q3时间片更长
同时再加个老化算法， 如果低优先级队列等待时间超过一个阈值，我们强制把他提升到更高一级。

核心优势就是时间片轮换的超绝决策，非常个性化。
比如我们的word程序，我们要做的只是在用户面前展示初始界面，特别快。我们一定是待在vip的q1队列的



从我们的word程序被选中，到它真正在CPU舞台上开始执行第一行代码，这中间发生了一个极其关键且昂贵的过程。这个过程叫什么**上下文开销**
不知道这样解释对吗，word程序在进程那个城堡，享受着进程设计的资源，这些资源、运行的状态等，就是上下文。
当去cpu运行时，是去一个陌生的，属于cpu的环境， 他要去适应。  
就是你在自己舞蹈室排练，和到大舞台的聚光灯下表演，资源、环境是不一样的。

切换前，比如说舞台上是chrome在表演，以及摆满了加载到CPU缓存里的数据， 以及提词器PC寄存器。 
现在我们让word上来，但chrome的数据不能全丢了，chrome后面还得来表演啊。
word上来，cpu缓存又难命中，不断表演缓存才变得适合word。但这样又不完全适合未来的chrome了。

### **第三幕：并行世界 (The Concurrent World)**

**`[场景]`**  
Word程序成功登上了CPU舞台！它的窗口出现在了你的屏幕上，光标在不停地闪烁。你心满意足地开始在键盘上敲击文字：“H-e-l-l-o-,- -O-S”。

`[旁白]`
在你看来，Word只是在简单地显示你输入的字符。但在它的“城堡”内部，一个看不见的“微型团队”已经开始高效地运作了。

- 一个“前台接待员”，负责接收你的每一次键盘敲击，并立刻把字符显示在屏幕上，保证你感觉不到丝毫卡顿。
    
- 一个“后台校对员”，在你打字的同时，就在默默地检查你输入的单词拼写是否正确。如果错了，它会在单词下方画出红色波浪线

这俩个员工在操作系统中，是进程中的俩个线程。
不过是用户级还是内核级呢？？
俩个线程是为了效率，不用切换上下文 
**校准**：这个说法**不完全准确**。

- 线程间**仍然需要**上下文切换。从“打字线程”切换到“拼写检查线程”，内核**依然需要**完整地执行上述的“保存A的硬件上下文 -> 加载B的硬件上下文”的流程。
    
- **但是**，正如我们之前分析的，因为它们属于同一个进程，所以这个切换**不涉及**地址空间的更换。这意味着内核**不需要**去切换页表，CPU的**TLB缓存**和大部分**数据缓存**都还能继续有效。
    
- **结论**：线程切换的**效率高**，不是因为它“没有”上下文切换，而是因为它的上下文切换是**“轻量级”**的，只切换了**硬件上下文**，而**没有**切换更昂贵的**“地址空间上下文”**。

不行，我感觉到这里必须严格讲清上下文的定义了，不用比喻，我需要严格理解各个情况的“上下文”，

**两个“员工”都需要频繁地访问同一份“文档数据”**，可能会碰到非原子性的矛盾，我们需要锁的原子性操作保持互斥状态，有『并行度』的损失，即损失一点效率

你写下了“Hello, OS”这句话。现在，你心满意足地按下了“Ctrl + S”保存快捷键。

这个“保存”的动作，比你想象的要复杂得多。Word进程（我们称它为**“前台应用进程”**）并不直接和硬盘打交道。它需要把“保存文件”这个请求，发送给操作系统中一个专门负责管理文件系统的**“文件系统服务进程”**。

这两个进程，是完完全全独立的两个“城堡”，内存互不相通。它们之间需要一座“桥梁”来传递信息。现在，轮到我们在第二章学的**进程间通信 (IPC)** 知识登场了

**为了将“保存'文档.docx'这个文件，内容是'Hello, OS'”这个请求，从Word进程传递给文件系统进程**
我们可以使用”消息传递“，也可以使用”共享内存“.

消息传递是一对一，共享内存是一个大池子大家按需自取
效率 共享>传递
安全 传递>共享

**假设这两个进程决定采用某种“消息传递”的方式进行协作。Word进程发送了保存请求后，它需不需要傻傻地一直等到文件系统进程回复“保存完毕”？或者，它可以采用一种更聪明的、不会让自己的界面卡死的“异步”工作模式？这种“异步”模式，如何用我们学过的某个同步原语（比如信号量）来实现？**

这个我真忘了， 异步难道不是，cpu轮换到他发现需要准备时，让他变成堵塞态，然后cpu直接处理下一个就绪态吗？ 哦，这样似乎，是针对CPU的”异步“概念。

你说得完全正确！你描述的“让他变成阻塞态，cpu直接处理下一个”，这是**操作系统调度层面**的异步，它保证了**CPU不会被闲置**。

而我们现在讨论的“异步”，是**应用程序设计层面**的异步。它要解决的问题是：**Word程序本身，作为一个整体，要不要被“卡住”**。

**我们来构建一下“同步 vs 异步”的工作流：**

- **同步保存 (Synchronous Save) - “傻傻地等”**
    
    1. Word进程（里的主线程）调用一个 save 函数，这个函数内部会向文件系统进程发送IPC消息。
        
    2. 发送完消息后，这个主线程就**停在原地，进入阻塞状态**，等待文件系统进程的“完成”回复。
        
    3. **后果**：在文件系统完成保存（可能需要几秒钟）之前，Word的整个用户界面将**完全冻结**。你无法进行任何操作，窗口会显示“未响应”。
        
- **异步保存 (Asynchronous Save) - “聪明的委托”**
    
    1. Word进程的主线程，在需要保存时，它**不亲自去发送IPC消息**。
        
    2. 它会创建一个**新的“后台保存线程”**。
        
    3. 主线程把“保存文件”这个任务，**委托**给这个后台线程，然后**主线程自己立刻返回**，继续响应你的鼠标和键盘操作。
        
    4. **后台线程**去执行那个会产生阻塞的IPC调用，它自己傻傻地等，但**完全不影响主线程**。
        
    5. **结果**：Word界面流畅如初，你甚至可以在它保存的同时继续打字。文件保存工作在后台默默进行。
        

你的Word文档已经保存完毕。但此时，系统的后台并不平静。一个“杀毒软件”进程，注意到了这个新创建的文件。几乎在你保存完成的同时，它也想打开这个文件进行扫描。

与此同时，Word进程还没有完全关闭这个文件。它可能还想执行一些收尾工作，比如写入一些最终的元数据（作者信息、最后修改时间等）。

于是，一个经典的冲突局面形成了：

- **Word进程**：已经持有了对这个文件的**“写入许可”**，现在它还需要申请系统的**“元数据锁”**，来写入最终信息。
    
- **杀毒软件进程**：启动时，为了保证自己扫描的权威性，它可能已经抢先持有了系统的**“元数据锁”**，现在它需要申请对这个文件的**“读取许可”**。
    

**[旁白]**  
两个进程，都手握着对方需要的东西，同时又在等待对方释放自己需要的东西。空气仿佛凝固了，系统的响应开始变得迟缓，鼠标指针变成了菊花，不停地旋转...


死锁
- 互斥，读和写不能同时
- 持有并等待，各自还需要申请
- 不可抢占，系统**不能**强行从Word进程手里，把那个“文件写入许可”给**夺走**，然后分配给杀毒软件。Word必须**自愿地**释放它。资源的释放权，完全掌握在持有者手中。
- 循环等待，A持有的是B要的，B持有的是A要的，但是他们都不释放，除非等到了要的东西，可以要等到要的东西又必须释放，陷入循环

**我们日常使用的Windows或Linux系统，在面对这种“僵局”时，通常采取了哪一种“治理策略”？请用我们之前那个“城市交通”的比喻来描述这种策略，并说明它的优缺点。**

### **方案一：破坏“循环等待”**

> 你的想法：“只能有一个被申请？”

这个想法非常接近核心。它的意思是，我们不能让Word和杀毒软件“随心所欲”地去申请资源。我们必须给它们的申请行为，加上一个**“规矩”**。

这个规矩，就是哲学家进餐方案一的精髓：**“资源排序 (Resource Ordering)”**。

**具体设计：**

1. 我们在整个系统中，对**所有**需要加锁的资源，进行一个**全局的、唯一的编号**。
    
    - 比如，我们规定：**“元数据锁”** 的编号是 **#100**。
        
    - **“文件写入许可”** 的编号是 **#200**。
        
2. 然后，我们为系统中所有需要加锁的程序，制定一条**铁律**：  
    **“无论你需要申请多少个锁，你都必须严格地按照资源编号，从小编号到大编号的顺序进行申请。”**
    

**我们来看看这条铁律，是如何拯救Word和杀毒软件的：**

- **Word进程**：
    
    - 它需要 #200 (文件锁) 和 #100 (元数据锁)。
        
    - 根据规则，它必须**先申请 #100**，再申请 #200。
        
- **杀毒软件进程**：
    
    - 它也需要 #100 和 #200。
        
    - 根据规则，它也**必须先申请 #100**，再申请 #200。
        

**现在，我们再来推演一下“最坏时序”：**

1. Word和杀毒软件同时启动。
    
2. 它们**都会去抢 #100 (元数据锁)**。
    
3. 假设**杀毒软件**运气好，先抢到了 #100。
    
4. Word在申请 #100 时，就会被**阻塞**。此时，Word手里**没有任何锁**。
    
5. 杀毒软件继续往下，去申请 #200 (文件锁)。因为文件锁是空闲的，它也成功了。
    
6. 杀毒软件完成工作，依次释放 #200 和 #100。
    
7. Word被唤醒，现在它可以畅通无阻地依次申请到 #100 和 #200。
    

**Aha! Moment**：  
通过强制规定一个**全局的申请顺序**，我们把之前可能出现的“A等B，B等A”的**“环路”**，拉成了一条**“直线”**的排队。所有人都朝着同一个方向申请资源，循环等待就从根本上被消除了。

---

### **方案二：破坏“持有并等待”**

> 你的想法：“等待时间到一定阈值就释放？”

这个想法，在实际系统中，被称为**“尝试加锁 (Try Lock)”**或者**“带超时的锁 (Timed Lock)”**。这是一种非常高级且实用的死锁处理方式！

**具体设计：**  
我们不要求程序员去记那些复杂的资源编号。我们只改变锁的行为。

- 我们把原来的 lock() 函数，升级成一个 try_lock_with_timeout(timeout) 函数。
    
- 这个函数的意思是：“我尝试去获取这个锁。如果成功了，就立刻返回成功。如果在指定的 timeout 时间内还没拿到，就**不要再等了**，立刻返回一个‘失败’的信号。”
    

**我们来看看Word进程的行为逻辑会如何改变：**

codeC

```
// Word进程的新逻辑
// 已经持有“文件锁” #200

// 尝试去获取“元数据锁” #100，最多等500毫秒
if (try_lock_with_timeout(metadata_lock, 500ms) == SUCCESS) {
    // 成功了！
    // ... 执行收尾工作 ...
    release(metadata_lock);
    release(file_lock);
} else {
    // 失败了！说明很可能发生了死锁！
    // 我不能再傻等下去了。
    
    // “主动放弃”：释放自己已经持有的资源
    release(file_lock); 
    
    // 退一步海阔天空，等一会儿再从头开始整个流程
    wait_for_a_random_time();
    restart_save_process();
}
```

**Aha! Moment**：  
这个方案，完美地体现了你说的“**等待时间到一定阈值就释放**”。

- 它通过设置一个“超时期限”，避免了无限期的“持有并等待”。
    
- 当发现可能陷入僵局时，它会**主动地、优雅地“退让”**，释放自己已有的资源，从而打破了死锁的僵局。
    
- 这是一种**“乐观”**的策略：它假设死锁不常发生，所以大胆地去尝试。一旦发现不对劲（超时），它又有能力从中**恢复 (Recover)**。


# **《一个Word文档的诞生》- 最终版故事模板 (T - Templatize)**

**序章：The Click - 创世纪**

- **故事**：双击图标，一个应用程序的生命从何而来？
    
- **核心概念 (主线)**：**进程 (Process)**
    
- **第一性原理**：进程是为了在混乱的硬件之上，实现**隔离与保护**而设计的**“资源容器”**。
    

**第一章：The Stage - 舞台与指挥家**

- **故事**：Word进程诞生了，但它和系统中成百上千个进程一样，都只是舞台下的“候场演员”。是谁，用什么规则，来决定它何时能登上CPU这个唯一的“聚光灯舞台”？
    
- **核心概念 (主线)**：**CPU调度 (Scheduling)**
    
- **第一性原理**：调度是为了解决**CPU稀缺性**与**用户体验**之间的矛盾，通过高速切换，制造“宏观并行”的**假象**。
    
- **展开 (枝叶)**：
    
    - **调度算法**的演进 (从FCFS到多级反馈队列的权衡)。
        
    - **上下文切换**：演员换场为何如此昂贵？（缓存失效）。
        
    - **进程状态**：演员的几种状态（候场、表演、后台等待）。
        

**第二章：The Team - 团队协作的效率革命**

- **故事**：Word登上了舞台，但它不是一个人在战斗。打字、拼写检查、语法高亮... 多个“员工”在同时工作。为什么不为每个员工成立独立的公司（进程），而是把他们组织在一个团队（线程）里？
    
- **核心概念 (主线)**：**线程 (Thread)**
    
- **第一性原理**：线程是为了在**进程**的“安全”容器内，追求**极致效率**而设计的**“轻量级执行流”**。这是一次用**“隔离性”**换取**“性能”**的经典权衡。
    
- **展开 (枝叶)**：
    
    - **用户级 vs. 内核级**：团队管理模式的权衡。
        
    - **线程切换 vs. 进程切换**：为何团队内部换人，比公司间换人快得多？
        

**第三章：The Chaos - 秩序的建立**

- **故事**：团队里的所有员工，都需要访问同一份文档。如果不建立规则，数据就会被他们七手八脚地改得一团糟。如何保证“同一时间，只有一个人能修改”？
    
- **核心概念 (主线)**：**互斥与锁 (Mutex & Lock)**
    
- **第一性原理**：锁是为了对抗并发环境下的**“非原子性”**，通过依赖**硬件原子性**，人为地在并行系统中引入**“串行点”**，用**“并行度”**的损失换取**“数据一致性”**。
    
- **展开 (枝叶)**：
    
    - **自旋锁 vs. 互斥量**：“忙等待”与“睡眠等待”的权衡。
        

**第四章：The Symphony - 精准的协奏**

- **故事**：秩序建立后，还需要协作。生产者-消费者、读者-写者、哲学家进餐... 甚至“保存文件”这个动作，都需要Word进程（前台线程）和文件系统进程（或后台线程）进行精准的“接力”。如何实现“我好了，该你了”的优雅通知？
    
- **核心概念 (主-线)**：**同步 (Synchronization) & 进程间通信 (IPC)**
    
- **第一性原理**：同步是为了解决**协作任务**的**“时序”**问题。IPC是为了解决**隔离进程**间的**“数据交换”**问题。
    
- **展开 (枝叶)**：
    
    - **信号量 & 管程**：从“瑞士军刀”到“安全保险箱”的设计思想演进。
        
    - **IPC三大模式**：管道、消息队列、共享内存的权衡。
        

**终章：The Gridlock - 僵局与破解之道**

- **故事**：在最复杂的协作中，Word和杀毒软件不幸陷入了“你等我，我等你”的死亡拥抱。如何从制度上预防或解决这种僵局？
    
- **核心概念 (主线)**：**死锁 (Deadlock)**
    
- **第一性原理**：死锁是多个进程在**竞争资源**过程中，因不合理的**请求顺序**而导致的**“循环等待”**僵局。
    
- **展开 (枝叶)**：
    
    - **四大策略**：预防、避免、检测、忽略（鸵鸟算法）的战略权衡。