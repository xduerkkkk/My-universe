# 操作系统内核
管理所有东西：硬件、cpu调度、内存
我们现在探讨的仍是cpu调度这块，线程要在cpu上运行。
但是，调度线程到cpu上，需要cpu从程序运行的用户态切换到内核态，这个过程上下文开销大，所以申请麻烦

在内核视角，**线程 (TCB)** 是直接被放入调度队列的、可被调度的基本单位。**进程 (PCB)** 是线程的“家”，它定义了线程可以使用的资源（内存空间、文件等），但它自己不排队、不运行。
在cpu运行的线程，有两种方式产生
- 一种是内核级线程，跟本上是内核调度的，不是进程产生的，进程向内核申请内核亲自动手。 但具体怎么用？
	- 内核会去调度。进程自己没有调度线程的权利，是**内核的调度器**，根据自己的全局调度算法（比如我们学的CFS），从这个公共池里挑选**它认为最合适的**线程，放到**它认为最合适的**CPU核心上去运行。进程**被动地**从“拥有多个KLT”这件事中**获益**（因为内核可能会把它的多个KLT并行地调度到多核上），但进程**不能主动地**去调度它们。
- 一种是用户级线程，进程自己创建线程这种数据结构， 然后内核呢，为什么能看到进程有一个内核级线程？  一个进程**至少要有一个内核级线程**作为其“执行的实体”。当操作系统创建一个进程时，作为“套餐”的一部分，它**必须**为这个进程**至少创建一个内核级线程**。否则，这个进程就只是一个空有资源（内存、文件）的“植物人”，它没有任何可以被CPU调度的“灵魂”，也就永远无法执行一行代码。



## 内核级线程
向操作系统内核申请、调用。
线程的具体操作都是内核亲自掌控
好处
- 真并发
- 不株连
缺点是申请调用成本高

# 用户级线程

