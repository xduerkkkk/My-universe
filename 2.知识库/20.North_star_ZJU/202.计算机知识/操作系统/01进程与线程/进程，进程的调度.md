进程是操作系统分配资源的基本单位
比如我运行了浏览器，整个浏览器就是一个进程，显然里面有很多小的程序，小的运行过程，那么这些在进程里的运行就是线程。 所以，进程大概率有多个线程。
详细讲进程组成的话，有他的身份证：pcb，记录进程描述和控制信息， 有程序，还有数据（这俩是进程的实体）， 最后还有工作区，就是进程的上下文。 我们把这些合起来称为进程

## 进程的调度
首先最简单的就是先来先处理 ，简单实现容易，保证公平性
但最常用的是时间片轮转处理 。
为什么要这样做... 嗯，不是为了效率吧，我感觉3个进程，先来先处理和轮转处理在cpu算力不变的情况下时间一样，甚至折腾地调度时间还稍微长一点点，那... 真的，我也想不明白了， 区别就是， 后者，能让每一个进程都快速地开启处理， 不要求处理完，但是快速开启处理很重
对！
响应时间是不同的！！
刚才的分析，忽视了一个问题，不同的进程可能需要的响应时间是不同的！
这下懂了吧，进程本来就买个可乐，前面有个其他进程买9999元豪华套餐，买可乐的等前面的搞完？ 胡闹。
- **先来先服务 (FCFS)**：它的设计目标非常单一，就是“简单”和“公平”（按顺序）。它可能会有不错的吞吐量（因为切换次数少，开销小）。但是，它的**“平均等待时间”**和**“响应时间”**可能会非常糟糕。
    
    - **汉堡店的比喻**：假设一个顾客点了一份需要准备30分钟的“佛跳墙”（一个计算量巨大的批处理任务），而你只是想买一瓶可乐（一个交互式命令，比如在终端里敲一下ls）。在FCFS模式下，你必须等佛跳墙完全做好，才能拿到你的可乐。你的**响应时间**是30分钟，体验极差。
        
- **时间片轮转 (Round Robin)**：它牺牲了一点点的**吞吐量**（因为增加了上下文切换的开销），换来的是**极大地优化了“响应时间”**。
    
    - **汉堡店的比喻**：厨师先花了1分钟准备佛跳墙的食材，然后立刻转向你，从冰箱里拿出可乐递给你（首次响应），接着又回去继续准备佛跳墙。你几乎立刻就拿到了你的可乐，**响应时间**可能只有几秒钟。虽然佛跳墙的总制作时间因为这次打断而延长了1分钟，但你的体验得到了保证


一个简单的“时间片轮转”模型，它假设所有进程都永远是“准备好被执行”的
还有进程是IO型的呢，只是启动“开始读文件”这个命令
一个更聪明的调度器，首先要能**区分进程的不同状态**。就像厨房经理不仅要看订单列表，还要知道每条生产线当前是“正在切菜”、“正在等烤箱”、还是“已经准备好，就等厨师了”。

## 进程的状态
不同进程不同状态
这里的状态，指的是时间片轮转算法时，调度器，看到的，轮转到面前的
- 运行态：正在占用cpu   估计就不久前，调度器安排cpu处理它的，现在又过来，问，还要继续吗？怎么处理我？
- 就绪态：它自身什么问题没有，乖孩子就眼睛水汪汪看着调度器，希望调度器让他去cpu那
- 阻塞态：它现在还阻塞着呢，也许需要IO的数据，也许xxx。不过也许再转几轮，就可以变成就绪态了。当然，运行态转几轮可能因为程序的需要，也有可能变成阻塞态

至此我突然理解，我之前想的是，时间片轮换到谁，谁的进程就前进一点点。这样把时间片轮换理解成处理进程的东西了，实际上时间片轮换只是调度器， 有处理能力的是cpu。调度器只负责，结合面前的人和cpu的状态，看面前的人要不要送去cpu处理。
但是cpu处理又是和时间片轮换同步的，就是转到运行态，cpu就处理一下， 然后ok，时间到了，转另一个人了，cpu就也停下，看看调度器下一个转的是谁。 那么这样说，转到运行态和就绪态，cpu都可以直接干活。 但是！转到阻塞态就不干活了吗！不，还是压榨一下cpu，所以有了就绪队列的说法

<font color="#f79646">不对，这个理解，是认为一堆状态的进程随机排列 然后时间片轮换就是随机看</font>
<font color="#f79646">但实际上，轮换是调度，是选择！  不是轮到谁处理谁，而是时间片的时间到了后，调度器选择谁，处理谁。</font>

那如果只有一个cpu的话，就只有一个进程是运行态，  就是正在处理的那个！ 
就绪态  在运行态时间片用完时 变成就绪态， 或者， 堵塞态等待事情完成后， 变成就绪态。
那堵塞态什么时候变的呢？   应该是运行态正运行到某个节点，突然发现此时要IO， 所以就把这个运行态变成堵塞态，踢下去。 此时没有一个运行态，几乎全是就绪态，这些就绪态在就绪队列里，我们用算法选出一个就绪态去运行，开启新的时间片，变成运行态。


对就绪队列响应时间的风险的话， 我们直接标记优先级。他们在队列时，就显示优先级别，我们优先处理级别最高的队列。
直接标记优先级，那优先级低的也有可能饿死
那能不能这样，比如优先级123， 我们按优先级1 连续取3次 然后紧接着2 取2次 优先级3 取一次 这么个周期循环？ 取的次数既能体现高优先级， 高优先级取一定次数转为低优先级，也保证低优先级没被饿死

我这个想法叫**加权轮询！**

那我们介绍一下多级反馈队列。
Q1Q2Q3代表优先级，Q1优先级最高。
无论什么就绪态，都暂时放到Q1.
我们要对他进行“测试”
我们会给Q1的进程很短的时间片，如果很短的时间片内，真的完成了，就说明，他值得Q1，因为不占用时间，我们很快就能给用户反馈。
如果完成不了，甚至还有很多，我们把它降级到Q2Q3的低优先级队列。因为完成不了说明耗费时间，是计算密集型，我们给他们很长的时间片！
然后宏观来看，就快速把Q1处理完，然后处理Q2Q3.
Q2Q3咋抉择，一样的，如果进程在Q2的时间片用完了还没结束进程，说明Q2还不够，退到Q3，Q3时间片更长
同时再加个老化算法， 如果低优先级队列等待时间超过一个阈值，我们强制把他提升到更高一级。


# 进程的创建和终止

## 创建
先fork， 把父进程所有状态复制到新的进程里。完全一样。唯一区分的点是父进程返回时返回进程的id，子进程返回0（这个“返回”指的是什么？是什么情景下的？）
就是调用fork函数，这句语言要返回一个状态码。我们可以

```C
pid_t child_pid = fork();

if (child_pid > 0) {
    // 我是父进程，因为我得到了子进程的PID
    // 我可以在这里执行 wait()
} else if (child_pid == 0) {
    // 我是子进程，因为我得到的返回值是0
    // 我可以在这里执行 exec()
} else {
    // fork() 出错了
}
```

exec（）：接着，子进程要干他的活了。毕竟复制出子进程就是为了多一个人出一份力的。之前父进程的任务会被替换。
## 终止
子进程把任务结束后，会执行exit（），内部资源全部释放，但有一个结果记录（之前工作时所记录的）。这个状态叫僵尸进程（都把资源释放完了，为啥还叫僵尸？）
它在系统的**进程表 (Process Table)** 中还占据着一个“户口”。这个“户口”就是它的PCB（进程控制块），里面只保留了最核心的“死亡信息”：它的PID，以及它的**退出状态码**（就是你说的“结果记录”）。

wait()  由父进程执行， 当创建子进程时，父进程就停止自己的工作，用wait()监控着子进程，（啊？那自己也不干活了，假如说只有一个子进程，那根本没啥用啊？还是说就是，召唤了一个子进程帮他干其他领域的事？）
是的，召唤子进程就是干其他领域的事的。
不过刚说的是阻塞式wait()
还有一个waitpid() **试探一下**我的子进程结束了没？如果结束了，就告诉我结果，把它回收掉；如果**还没结束，就别让我等了**，立刻告诉我‘还没结束’，我要继续干我自己的活。

当感应到子进程执行exit（）了后，会彻底进行回收。


- **一步到位模型**的调整空间是**“声明式 (Declarative)”**的。你通过**函数参数**来声明你想要的最终环境是什么样的。它更简单、更直接。
    
- **fork()/exec() 模型**的调整空间是**“命令式 (Imperative)”**的。你通过在子进程中**执行代码**来动态地、一步步地构建你想要的环境。这赋予了你无限的灵活性和编程能力。



### **解惑 1：除了公平和效率，进程调度还考虑什么？**

“公平”和“效率”是两大基石，但作为架构师，我们需要把它们分解成更具体、可量化的工程指标。同时，还存在一个经常被忽略但至关重要的第三维度。

**1. 系统为中心 (效率导向)**

- **CPU利用率 (CPU Utilization)**：这是最硬的效率指标。要确保CPU这个最宝贵的计算资源，尽可能少地处于空闲状态。我们之前讨论的“阻塞时立刻切换”，主要就是为了优化这个指标。
    
- **吞吐量 (Throughput)**：单位时间内完成的进程（作业）总数。给计算密集型任务更长的时间片，减少切换开销，就是为了提升吞吐量。
    

**2. 用户为中心 (体感导向)**

- **周转时间 (Turnaround Time)**：指一个进程从“被创建”到“彻底完成”的总耗时。它等于**等待时间 + 运行时间**。对于用户提交的批处理任务（比如渲染一个视频），这个时间越短越好。
    
- **等待时间 (Waiting Time)**：进程在“就绪队列”里空等的时间总和。这是用户体感差的直接来源之一。
    
- **响应时间 (Response Time)**：从用户发出指令（点击鼠标）到**第一次**看到系统反应的时间。这是保证系统“交互性”的核心指标。我们之前讨论的“短时间片”和“高优先级”，主要就是为了这个指标。
    
- **公平性 (Fairness)**：即你提到的，确保每个进程都能获得合理的CPU时间，防止“饥饿”。“老化”机制就是为此服务的。
    

**3. （关键补充）可预测性 (Predictability)**  
在某些特殊的操作系统中，这个因素甚至比其他所有因素都重要。

- **硬实时系统 (Hard Real-time Systems)**：比如汽车的ABS防抱死系统、心脏起搏器。任务**必须**在指定的截止时间（deadline）前完成，晚了0.01秒都可能导致灾难。这类系统的调度算法，首要目标不是快，而是**“保证在规定时间内完成”**。
    
- **软实时系统 (Soft Real-time Systems)**：比如视频会议软件、在线游戏。它希望任务能尽量按时完成，偶尔的延迟（比如画面卡顿一下）虽然体验不好，但不会造成灾难性后果。