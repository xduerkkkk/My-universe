hg任何进程之间都是互斥状态，但是当有进程为了同一个大任务时，他们是兄弟，他们会商量、通知，他们会由互斥状态转化为更有规矩的同步状态吧

诶，锁的话，是不管你到底商量好没有，只要一个进程用资源，锁起来，就解决了。
简单的检查-设置的逻辑，，存在“抢锁”的可能？俩个人同时发现locked在此刻空了，怎么办呢？  
一人可能进去了 还没来得及锁  另外一人就也来了， 造成崩溃


# 锁
TestAndSet 的原子性
把检查和设置依托于硬件绑定在一起
是自旋锁，是不断问询的（一直运行态）
而睡眠锁 是等通知的，只不过有通知成本和状态切换成本（运行态--阻塞态--运行态）

# **互斥量**
，互斥量就是把睡眠锁管理起来了？ 如果刚才只学到睡眠锁，若一个资源有多个睡眠锁 ， 那些堵塞的可能同时被叫起来，而且叫起来的时候已经锁没了，就引起抢锁风暴了。 而互斥量是决定叫哪个锁，决定好叫醒的时候，那个锁都在的，直接进资源，锁就没动。除非他干完出来，发现没进程等待，就把锁关了。  
所以，互斥量方法中，要么是自己发现，没锁，然后过去 上锁 。要么是被上个进程呼叫， 然后进去 不动这个锁  
二者出去的时候流程都是一样的 检查。  
那互斥量方法中“要么是自己发现，没锁，然后过去 上锁 ” 如果有多个进程同时发现了呢？

基于原子操作的“自旋”尝试**，来解决了这个最根本的“第一步抢锁”问题。


一个生产者进程P，负责生产数据，并把它放入一个共享的缓冲区；一个消费者进程C，负责从缓冲区取走数据进行消费。

- **同步要求1**：如果缓冲区是**空的**，消费者C必须**等待**，直到生产者P放入了数据。
    
- **同步要求2**：如果缓冲区是**满的**，生产者P必须**等待**，直到消费者C取走了数据。
    

我的问题是，架构师：  
**你能否尝试只用我们目前学到的“互斥量 (Mutex)”这个工具，来解决上述的“生产者-消费者”同步问题？**
我没理解到底有什么同步问题呀 哦哦，就是，消费者假如发现房间是绿灯了，但是没资源，所以，进去了也没用。
嗯。那这个时候，就去等待，反正互斥量是，进程只要看到是绿灯（到底怎么称呼，就是“没锁”状态”吗？）   就进去资源的地方（咋称呼，缓冲池？）  那消费者就先等着，反正是没锁，后面
生产者进来，生产了后， 出去呼叫消费者，消费者就直接取了。

嗯。。。有什么笨拙的地方吗？  我决定消费者等生产者这个“低效时刻”是不可避免的呀
“当缓冲区不再为空时，请叫醒我” 这个做不到啊，那之前学互斥量的“叫醒服务”，是只要有进程出缓冲区，就叫等待队列，无法设置特殊条件是吧。

# 信号量
两个原子操作，所描述的操作都是不可打断的
- P（）表示请求，而请求的资源填在（）里。括号里面是数字，数字大于0，就说你请求的这个车位，有空。 那么请求成功，请求资源数字-1.  如果请求资源=0，程序在P这个代码这挂着，阻塞
- V() 表示增加，括号里面的资源有成员离开。 括号的资源数字+1。 此时会看看外面有阻塞的没，有的话唤醒。
- 同时 进行操作的时候 必须要求mutex为1

以生产者为例子
empty是空位对象，full是有位对象，mutex等于1（我还是不太理解，为啥呢）
1. 先是P(empty)  因为有空位才能执行生产者的操作
2. P(mutex)   进去 然后， mutex变成0 意味着”锁上“ 0意味锁！
3. 执行生产者自己的操作，实际上是占用一个槽位
4. V(mutex) mutex+1  变回1 释放锁
5. V(full) 生产者的事情全部完结，有位对象+1

为啥mutex=0意味锁上呢  P（mutex）是请求锁这个资源！若mutex=0说明请求资源没了，也就是锁在别人手上别人锁着门呢，按照P的逻辑，P就会阻塞。

死锁，是说
P（empty）和P（mutex）换位置
这会出现一个情况，若先Pmutex 把锁抢到，empty却是0的话，生产者会阻塞等待的。
而另一边，消费者第一步是P（full） 没问题  接着P（mutex） 锁背生产者拿着啊，所以也消费不了。所以变成了生产者等待有人消费，但他睡的时候怀里揣着锁，导致别人根本没法消费。

# 读写者
## 读者优先
rm_mutex 用于表示写者与读者的互斥，在读者优先例子中，只有写者用的上
写者：
- P(rm_mutex) 请求写，如果rmmutex=0，说明有读者锁上了，自己乖乖等
- 若等上了，（咦，如果有其他写者，是不是队列先来后到？我忘记”竞争“知识点了） 消耗刚恢复的rm_mutex 变回0  不让其他读者写者进入
- 写中....
- V(rm_mutex)  释放

```c
while (true) {
    // 准备写数据...

    // 申请“读写锁”。
    // 如果有任何读者在读(rw_mutex已被第一个读者锁上)，
    // 或者有另一个写者在写，
    // 那么这个写者就会在这里阻塞。
    P(rw_mutex);

    // --- 临界区开始 ---
    // (此时，写者是场内唯一的玩家)
    // ...执行写入操作...
    // --- 临界区结束 ---

    // 释放“读写锁”。
    // 如果有其他读者或写者在等待，唤醒他们去竞争。
    V(rw_mutex); 
}
```

读者：
mutex是用来保护read_count的
- P(mutex) 只有我一个人修改read_count 让其++
- 如果readcount是1 说明我是第一个读者，那么我为我的读者兄弟们，使用p(rm mutex) 不让写者进来 
- V(mutex) 读者兄弟可以来了。 不过我还没读呢，我现在过去读
- 读中....
- 读完了，我要走了。所以依然pmutex和readcount--
- 如果readcount减完是0 说明我是最后一个读者，那么下来可以让写者进来了，V(rw_mutex)
- V(mutex) 刚修改了readcount，别忘了释放，不然霸占了

```c
while (true) {
    // 准备读数据...

    // --- 读者入场管理 ---
    // 1. 锁住计数器，准备修改它
    P(mutex); 
    read_count++; // 读者数量加1

    // 2. 判断自己是不是第一个读者
    if (read_count == 1) {
        // 如果我是第一个，我有责任为所有读者锁门，挡住写者
        P(rw_mutex); 
    }
    // 3. 解锁计数器
    V(mutex); 


    // --- 临界区开始 ---
    // (此时，可能有多个读者在这里共存)
    // ...执行读取操作...
    // --- 临界区结束 ---


    // --- 读者离场管理 ---
    // 4. 锁住计数器，准备修改它
    P(mutex);
    read_count--; // 读者数量减1

    // 5. 判断自己是不是最后一个读者
    if (read_count == 0) {
        // 如果我是最后一个走的，我有责任为所有读者开门，通知写者可以进了
        V(rw_mutex); 
    }
    // 6. 解锁计数器
    V(mutex);
}

```

## 写者优先

写者：
```c
while (true) {
    // 准备写...

    // 1. 关上“读者入口”的大门，阻止新读者进入。
    //    这是“写者优先”的第一次宣告！
    P(read_try); 

    // 2. 像以前一样，等待场内的人（无论是读者还是另一个写者）清空。
    P(rw_mutex); 
    
    // --- 临界区 ---
    // (现在我是唯一的王)
    // ...执行写入...
    // --- 临界区 ---

    V(rw_mutex); // 释放场地

    // 3. 重新打开“读者入口”的大门。
    V(read_try);
}

```


读者：

```c
while (true) {
    // 准备读...

    // 1. 先看看“读者入口”的大门是否开着。
    //    如果一个写者正在等待(已经执行了P(read_try))，
    //    那么这个读者就会在这里被阻塞。
    //    这就是“写者优先”的核心体现！
    P(read_try); 

    // --- 读者入场管理 (和之前一样) ---
    // 2. 锁住计数器
    P(mutex);
    read_count++;
    if (read_count == 1) {
        // 如果我是第一个读者，我要负责为我们这个（刚被允许进入的）读者团体锁门
        P(rw_mutex);
    }
    V(mutex); // 解锁计数器

    // 3. 我已经成功进入了读者团体，现在可以把“读者入口”的门让给下一个读者了。
    //    这允许其他读者在我读书的时候，也能通过第一道门。
    V(read_try);


    // --- 临界区 ---
    // ...执行读取...
    // --- 临界区 ---


    // --- 读者离场管理 (和之前一样) ---
    P(mutex);
    read_count--;
    if (read_count == 0) {
        // 我是最后一个读者，负责为团体开门
        V(rw_mutex);
    }
    V(mutex);
}

```


# 哲学家进餐
0 1 2 3 4 
