# 进程
## 概念
为程序，配置数据结构为”进程控制块“---PCB ， 用来描述进程的基本情况和状态从而能管理
而进程实体，是由
- 程序段
- 数据段
- PCB  描述、控制管理、资源分配
- 工作区 一个动态区域 保存局部变量、传递参数等
组成
### 特征
- 动态性 有消亡嘛
- 并发性 既存在多进程
- 独立性  PCB的建立 就是为了资源的边界感
- 异步性

系统对其的控制，是由”原语“实现的， 原子操作，不能被中断
## 状态及转换
创建态（申请PCB、分配资源中...） --- 就绪态--- 被cpu”看上“即可运行态 
需要某资源，无奈等待 ，为阻塞态。
终止态，收回资源，释放中

![](../../../../../assets1/image/期末应试-1763644776044.jpeg)

很好想象
## 线程
线程是进程”旗下“的具体”员工“ 各线程共享进程的全局变量、地址空间、子进程、信号量
而他们独有程序计数器、寄存器、栈、状态字、TCB来工作

## 调度算法
FIFO 或者叫FCFS  太基础了
RR 时间片轮转法 纯粹看时间 轮着来 （算不算有公平性？算吧？）牺牲了一点点的**吞吐量**（因为增加了上下文切换的开销）  也算非抢占调度方式
下面是抢占式调度方式？
基于优先数  种姓制度了属于是， 挺好， 有些进程就是要优先服务
基于优先数还可以再详细，再好一点：
多级反馈队列调度算法
	Q1Q2Q3代表优先级，Q1优先级最高。
	无论什么就绪态，都暂时放到Q1.
	我们要对他进行“测试”
	我们会给Q1的进程很短的时间片，如果很短的时间片内，真的完成了，就说明，他值得Q1，因为不占用时间，我们很快就能给用户反馈。
	如果完成不了，甚至还有很多，我们把它降级到Q2Q3的低优先级队列。因为完成不了说明耗费时间，是计算密集型，我们给他们很长的时间片！
	然后宏观来看，就快速把Q1处理完，然后处理Q2Q3.
	Q2Q3咋抉择，一样的，如果进程在Q2的时间片用完了还没结束进程，说明Q2还不够，退到Q3，Q3时间片更长
	同时再加个老化算法， 如果低优先级队列等待时间超过一个阈值，我们强制把他提升到更高一级。
	
再补充几个
SJF 短作业优先调度 其实就是把短进程视作”优先“  显然会有长进程饥饿现象
高响应比优先调度 综合FCFS和短作业  等待时间+要求服务时间  /  要求服务时间

# 进程间作用
感觉同步和互斥的定义中， 区别就是，同步指A、B协同完成一个任务，比如A向缓冲区提供数据，B从缓冲区提取数据，这是，自然而然造成的，“直接”制约关系，都明白，互相有次序的等待，才能完成自己的任务。
互斥，是A和B都想访问一个资源，额，所以称“间接”制约关系，是我没抢到，所以只能不乐意地让给你

同步是自然而然可以实现的，互斥还是要人为干预的。
- 双标志先检查法： 先看看对方的flag 如果对方想 那就等待。对方不想，就设立自己标志，然后进去。有可能时间撞上了，俩人同时看对方，结果就是，以为对方不来，就都进来了。
- 双标志后检查法：那先设立标志再检查呢。 一样，如果动作撞上了， 双方都检查对面“想进” 那就一直饥饿 循环等待
最终 我们使用peterson算法  除了flag 多一个turn  turn能赋值 赋值到对面（优先让别人进） 
turn是共享变量，无论如何最后只能重写到一个值。turn的最终值决定了哪个进程被允许先进入临界区。

更优化的，是硬件层面，实现“原子操作”
我们引入“互斥锁”这个共享变量，一个进程想进临界区时调用acquire获得锁（原子操作，可以理解为，不可能有大于两个进程同时acquire，一定只有一个acquire成功） 若可用 就进去 上“锁”  当其他的acquire时， 因为锁不可用，所以会被阻塞。直到使用的进程释放锁。
不过，这属于“自旋锁” 会有进程一直“轮询”的情况存在 

## 信号量
我感觉，这是在假设， 我们的“临界区”S是有多个资源的区域？
P() 是进入区并占用一个资源 V()是退出区 释放一个资源
啊 巧的是 如果我们只假设S =1   也就是只有一个资源  我们能很好的get到同步与互斥如何实现

互斥的话
那就
P 操作  V  就ok了呀 