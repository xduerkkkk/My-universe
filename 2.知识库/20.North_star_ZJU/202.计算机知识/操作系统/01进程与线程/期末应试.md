# 进程
## 概念
为程序，配置数据结构为”进程控制块“---PCB ， 用来描述进程的基本情况和状态从而能管理
而进程实体，是由
- 程序段
- 数据段
- PCB  描述、控制管理、资源分配
- 工作区 一个动态区域 保存局部变量、传递参数等
组成
### 特征
- 动态性 有消亡嘛
- 并发性 既存在多进程
- 独立性  PCB的建立 就是为了资源的边界感
- 异步性

系统对其的控制，是由”原语“实现的， 原子操作，不能被中断
## 状态及转换
创建态（申请PCB、分配资源中...） --- 就绪态--- 被cpu”看上“即可运行态 
需要某资源，无奈等待 ，为阻塞态。
终止态，收回资源，释放中

![](../../../../../assets1/image/期末应试-1763644776044.jpeg)

很好想象
## 线程
线程是进程”旗下“的具体”员工“ 各线程共享进程的全局变量、地址空间、子进程、信号量
而他们独有程序计数器、寄存器、栈、状态字、TCB来工作

## 调度算法
FIFO 或者叫FCFS  太基础了
RR 时间片轮转法 纯粹看时间 轮着来 （算不算有公平性？算吧？）牺牲了一点点的**吞吐量**（因为增加了上下文切换的开销）  也算非抢占调度方式
下面是抢占式调度方式？
基于优先数  种姓制度了属于是， 挺好， 有些进程就是要优先服务
基于优先数还可以再详细，再好一点：
多级反馈队列调度算法
	Q1Q2Q3代表优先级，Q1优先级最高。
	无论什么就绪态，都暂时放到Q1.
	我们要对他进行“测试”
	我们会给Q1的进程很短的时间片，如果很短的时间片内，真的完成了，就说明，他值得Q1，因为不占用时间，我们很快就能给用户反馈。
	如果完成不了，甚至还有很多，我们把它降级到Q2Q3的低优先级队列。因为完成不了说明耗费时间，是计算密集型，我们给他们很长的时间片！
	然后宏观来看，就快速把Q1处理完，然后处理Q2Q3.
	Q2Q3咋抉择，一样的，如果进程在Q2的时间片用完了还没结束进程，说明Q2还不够，退到Q3，Q3时间片更长
	同时再加个老化算法， 如果低优先级队列等待时间超过一个阈值，我们强制把他提升到更高一级。
	
再补充几个
SJF 短作业优先调度 其实就是把短进程视作”优先“  显然会有长进程饥饿现象
高响应比优先调度 综合FCFS和短作业  等待时间+要求服务时间  /  要求服务时间

# 进程间作用
感觉同步和互斥的定义中， 区别就是，同步指A、B协同完成一个任务，比如A向缓冲区提供数据，B从缓冲区提取数据，这是，自然而然造成的，“直接”制约关系，都明白，互相有次序的等待，才能完成自己的任务。
互斥，是A和B都想访问一个资源，额，所以称“间接”制约关系，是我没抢到，所以只能不乐意地让给你