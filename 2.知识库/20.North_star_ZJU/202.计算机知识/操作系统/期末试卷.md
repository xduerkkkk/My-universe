# 卷1
进程调度，发生在进程状态改变的方方面面 
- **A (进程生成)**：新进程创建出来放在哪里？就绪队列。既然来了新任务，调度器就要决定：是让当前进程继续跑，还是让新来的跑？（抢占式调度）。**所以会调度**。
- **B (进程退出)**：当前进程死掉了（Exit），CPU 空出来了。这时候必须选个接盘侠，**必须调度**。
- **C (用户函数/系统调用)**：如果这个函数里有 I/O 操作或 sleep，进程会阻塞，CPU 必须换人。**会调度**。

MMU = **Memory Management Unit**（内存管理单元），**位于 CPU 中**。现在 MMU 都是集成在 CPU 芯片里的硬件电路，负责把逻辑地址瞬间变成物理地址。 不是主存（内存条）的一部分，它是逻辑部件。


多级页表是为了**节省连续的内存空间**（空间换空间），但它**牺牲了速度**（多了查找层级）。加速转换靠的是 **TLB（快表）**，而不是多级页表。

多级页表或者带“有效位”的页表，允许不存储未使用的地址映射。

### **疑问 2：多级页表为什么能“允许不存储未使用的地址映射”？（节省空间原理）**

这个概念比较抽象，我用一个**“图书馆目录”**的比喻来解释。

**背景**：假设一个程序（进程）理论上可以很大（4GB），对应需要 100 万页。

- **单级页表（死板的目录）**：
    
    - 就像一本**巨大的目录书**。不管你这个程序实际上只写了 3 行代码（只用了 1 页），系统强制要求你必须买一本能写 100 万行的目录书。
        
    - 第 1 行：有数据。
        
    - 第 2 行到第 100 万行：**全是“空”**。
        
    - **后果**：这本目录书本身就占了很大内存（比如 4MB），而且全是空白页，太浪费了！
        
- **多级页表（灵活的目录）**：
    
    - 我不买大书了，我把它拆成**“章目录（一级）”**和**“节目录（二级）”**。
        
    - **一级页表**（章目录）：只有 1024 行。
        
        - 第 1 章：有内容 -> **指向一本薄薄的“第 1 章节目录”**。
            
        - 第 2 章：没内容 -> **填 NULL（空）**。
            
        - ...
            
        - 第 1024 章：没内容 -> **填 NULL**。
            
    - **结果**：因为后面所有的章都是空的，**我就不需要去创建（购买）后面那些“节目录”了**！
        
    - **节省**：我只需要维护一张很小的一级表 + 一张很小的二级表。剩下的几千张二级表根本不用创建。
        

**结论**：  
多级页表通过**“如果一级目录是空的，就不创建对应的二级表”**这种方式，极大地节省了**页表本身占用的内存空间**。

---

缓冲（Buffering）的主要目的是**平滑 CPU 和 I/O 设备的速度差异**。真正“提高设备利用率”的大杀器是 **SPOOLing（假脱机）**技术，它能把独占设备变成共享设备。

SPOOLing 就是典型的虚拟化技术（让大家都以为自己拥有打印机）。

### **8. 计算机通电开启后，操作系统最终被加载到的位置是哪里?**

- **你的选择**：C （我看你画了个问号，是犹豫 BIOS 吗？）
    
- **正确答案**：**C (RAM)** （**正确！**）
    
- **诊断**：分清“源头”和“目的地”。
    
- **解析**：
    
    - **A (BIOS)** / **B (ROM)**：这是**源头**。电脑一通电，先读取 ROM 里的 BIOS 程序。
        
    - **加载过程**：BIOS -> 读取硬盘（MBR） -> 找到操作系统内核 -> **搬运到 RAM（内存）** -> CPU 开始执行 RAM 里的指令。
        
    - **结论**：操作系统也是个软件，软件要运行必须进内存（RAM）。
