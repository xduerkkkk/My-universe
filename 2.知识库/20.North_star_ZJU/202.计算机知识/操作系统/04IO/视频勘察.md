首先，本章节讲
操作系统怎么管理和外部设备的交互(IO设备)
那IO设备有很多，我们可以用很多种方式去分类
我觉得最好想的是
人机交互，如鼠标键盘；信息交互 ，如硬盘； 通信交流 。

ok 那么到底，操作系统怎么去管理IO？

数据流应该是这样的
CPU，可以代表操作系统的意志？ 然后把信息传递给寄存器这些硬件，
硬件的信息怎么转译？ 有个叫IO逻辑的东西，是硬件，每个设备（键盘、硬盘、网卡）都有**自己专属的**控制器。
他负责把信息，或者说命令，向设备传达！
传达这一点，势必最终是硬件传达，这个最后一步，就是与设备的接口！ 

那么“IO控制器”这个名词？ 应该指代？刚才那个中间人！

OK，有数据流这个框架了。

我们知道每一个设备都有一个转述的IO控制器作为中间人。
他们控制的方式一样吗？
不一样：
- 程序直接控制
- 中断驱动
- DMA
- 通道控制
我们先不陷进去细节， 只要知道 不同IO控制器 与设备的“传达”、“交互”，都不同
<font color="#f79646">这个理解错误！</font>
这讲的是 **CPU (代表驱动程序)** 与 **I/O控制器** 之间的交互方式。 
**位置**：位于 **设备驱动程序 <---> I/O控制器** 这一层。
- **物理设备**（如磁盘盘片）和 **I/O控制器** 之间的交互是内部的、电子信号级的，操作系统**看不见也不管**。
- 操作系统（驱动程序）只跟 **I/O控制器** 说话。
- **轮询**：驱动程序（CPU）一直问控制器：“好了吗？”
- **中断**：控制器发信号给CPU：“我好了！”
- **DMA**：CPU把总线控制权交给DMA控制器，DMA控制器直接搬运数据，搬完发中断。

刚才是硬件，现在我们回到软件！！！

首先，软件应当指一堆程序？
比如 我们想让计算机打印出个东西，我们会用print(...) 这是在库函数里的， 这个叫**用户层软件**。编码了“print()"的逻辑？你写 printf("Age: %d", 18)，它得先把 %d 替换成字符 1 和 8，拼成字符串 "Age: 18"。这是纯计算逻辑。它通常不会立刻找操作系统，而是先把这串字符放到**用户空间的一个数组**（缓冲区）里攒着。 

printf 的源码里写着：“当我把格式化搞定，缓冲区攒满后，**我就去调用 write()**。”
**【系统调用发生！】** —— CPU 状态位改变，权限提升，跳进内核。
这个就叫**系统调用接口/IO应用接口** write() 既是一个**系统调用**（因为它触发了模式切换），也是**I/O应用接口**的一部分（因为它符合标准规范）。    

然后这个信息 会进入“设备独立性软件” 他做了很多，（怎么找我要的设备？**缓冲 & 缓存**，IO调度，设备保护，块与字符设备的抽象逻辑）呃，携带信息仍然是write () 吧    ，只是说，去处理一下，像”中间人“  它调用下层接口时，**输入**：write(fd, "hello")指令变成了 —— scsi_disk_driver_write(具体的设备结构体, "hello")。
然后使用设备驱动程序接口 进入设备驱动程序，（所以接口的意思是，某个区域的入口吗？）
让其进行翻译为硬件指令
这下CPU就能直接把设备驱动程序翻译的语言，写入寄存器等硬件。到底怎么描述？
- **场景复现**：
    
    1. **驱动程序的代码（写在内存里）**：MOV 0x3F0, 0x01 （汇编语言：把数值1放入地址0x3F0）。
        
    2. **CPU（读到了这句话）**：哦，让我把1写到0x3F0。
        
    3. **硬件机制**：CPU发现 0x3F0 不是普通内存地址，而是一个**I/O端口地址**。
        
    4. **动作**：CPU通过系统总线，把 1 这个电信号，发送到了编号为 0x3F0 的**I/O控制器寄存器**里。
        
    5. **I/O控制器**：看到了寄存器里变成了1，立刻控制磁头开始移动。


转述后信息如何流动？
- 怎么找我要的设备？ ”设备独立性软件“干的，用到了表。当然他还有很多功能，先不陷入
- 把”打印“具体翻译为设备听懂的信号， ”设备驱动程序“
- 设备不能光埋头干，还得给我回应。用的是”中断处理程序“ 


现在，我们再软件硬件对照一下！

**CPU传达意志**  正是CPU忠实地执行着设备驱动程序的每一行代码。 
存到寄存器上，这个代码就包含了“设备独立性软件找到的具体设备，和我们刚才转述print的操作write”


下面，依然是这个信息流中的详细知识点

轮询、中断、DMA 都讲的是，硬件设备，与IO控制器的直接交互？相当于设备与CPU的间接交互？
IO应用接口，是在说什么呢？ 块与字符黑色版，阻塞与非阻塞IO，是如何填入框架的？
IO调度、缓冲、缓存
、假脱机呢  
应用程序IO接口 设备驱动程序接口， 这些接口，是怎么理解的？


假脱机  搞不懂 不太清楚
然后刚才软件层的，细的知识点， 只在那个“设备独立软件”了
其俩个功能   设备的分配与回收  缓冲区管理




# 磁盘
然后再一个独立知识点 磁盘 
首先视频展示了磁盘的样子
直观感受了
- 磁头臂、磁头
- 磁盘
	- 磁道
	- 扇区（磁盘块）
- 盘面
- 柱面
![](../../../../../assets1/image/视频勘察-1763521893823.jpeg)
所以可以有个坐标（柱面号（哪个磁道），盘面号（第几层）、扇区号（哪一块））
我疑惑的是 最内侧的磁道，面积最小，数据密度最大，  言外之意是，每一个磁道 其数据量相同吗？
扇区 每个地方数据相同很好理解。
如何读写数据？
先磁头移动到对应磁道（根据柱面号）  然后盘面会旋转， 选择的时候磁头会读取扇区号，

## 调度算法
- 寻道时间 找磁道
- 延迟时间 “找”扇区
- 传输时间 读写时间

操作系统影响的只能是寻道时间？为什么？
哦哦 理解了 这个视角，是放在“有很多磁道要寻找”的情况 我们如何排序 好比好多进程。
另外，磁头有一个“初始位置”
- FCFS 先来先服务
- SSTF 最短寻找时间优先 有点贪心 只能是局部最优 像第一个的话，就是找离初始位置最近的.会有饥饿风险 
- SCAN 扫描算法  只有磁头移动到最外层磁道时才能往内移动 反之一样。
	针对SCAN缺点的改进 
	- LOOK算法，在SCAN基础上加一个观测，如果移动方向上没有别的请求立即改变方向 
	- C-SCAN算法 额 SCAN是左到右 到头 从右往左 到头  而C-SCAN是定方向 比如说左到右 那就右 到头 再次从左往右
		- C-LOOK算法 结合LOOK和C-SCAN

延迟时间：磁盘读一个扇区的数据后要有一段时间处理
- 交替编号：能减少读连续逻辑扇区所需的延迟时间。 我疑惑了，那如果原来要读2、4、6 本来没有延迟时间的问题，交替编号后，可能246就有延迟时间问题了啊。有一种拆东墙补西墙的感觉。但也许 我们常常读的是连续的？ 
- 地址结构的设计，其坐标命名本身就有此效果
- 错位命名 仍然是服务于读连续扇区  然后由于磁盘旋转特性想出的方法

## 磁盘格式化

分区、逻辑格式化：c盘在里面的磁道  D、E依次在外面 