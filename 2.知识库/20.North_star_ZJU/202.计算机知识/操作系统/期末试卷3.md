### **提高单机资源利用率的关键技术是（ D ）**

- **你的选择**：B (脱机技术) —— **错**。
    
- **正确答案**：**D (多道程序设计技术)**
    
- **你的疑惑**：为什么不是 B？
    
- **硬核解析**：
    
    - **B (脱机技术)**：这是为了解决 I/O 设备慢的问题（比如先由外围机把磁带读进去）。它确实提高了 I/O 效率，但不是系统级的核心变革。
        
    - **D (多道程序设计)**：这是**操作系统诞生的标志**！
        
        - **原理**：内存里同时装好几个程序。当程序 A 去做 I/O（比如读文件）时，CPU 不闲着，立马切换去跑程序 B。
            
        - **结果**：CPU 和 I/O 设备并行工作了，**整体资源利用率**才发生了质的飞跃。
            
    - **结论**：提到“资源利用率”或“并发”，由于**多道程序**是祖师爷，选它准没错。





### **4. 死锁资源计算（经典算术题）**
*   **系统有 4 个进程，每个最多需要 3 个资源。保证不发生死锁，至少需要多少资源？**
*   **你的选择**：B (4个) —— **大错特错！**
*   **正确答案**：**C (9个)**
*   **你的疑惑**：怎么算的？

**死锁最坏场景法（Pigeonhole Principle / 抽屉原理）：**

1.  **构造“最坏情况”**：
    *   我们想让死锁发生，就要让所有人都**卡在最后一步**。
    *   每个进程需要 3 个。最坏的情况是：**每个人都拿到了 2 个**，手里拿着 2 个，在那儿等第 3 个。

2.  **计算持有量**：
    *   4 个进程，每人拿 2 个（即 $3-1$）。
    *   总共占用了：$4 \times 2 = 8$ 个资源。
    *   **此时系统死锁**（因为剩下的资源是 0，大家都凑不齐 3 个，谁也不肯放手）。

3.  **打破死锁**：
    *   只要**再多给 1 个**资源。
    *   这 1 个资源随便给谁（比如给进程 A），进程 A 就凑齐 3 个了！
    *   A 吃完了，就会释放它占用的 3 个资源。
    *   这 3 个资源流回池子，B、C、D 就都能吃饱了。

**万能公式（背下来）：**
设进程数为 $N$，每个进程最大需求为 $K$。
**不发生死锁的最少资源数** = $N \times (K - 1) + 1$

**套用本题**：
$4 \times (3 - 1) + 1 = 4 \times 2 + 1 = 9$

---

### **2. 管程可以用来控制进程的同步与运行。（×）**

- **你的判断**：✓ （错）
    
- **你的疑惑**：管程不就是干同步的吗？
    
- **死抠字眼**：
    
    - 管程（Monitor）确实是用来处理**同步**和**互斥**的（比如代替信号量）。
        
    - 但是！它管不了进程的**运行（调度）**。
        
    - **谁管运行？** 是 **处理机调度（Scheduler）**。
        
    - **逻辑**：管程只是一个“高级的锁”，它决定谁**能**进临界区，但它决定不了CPU**什么时候**给你时间片。
        

---

### **3. 页是信息的物理单位，段是信息的逻辑单位。（×）**

- **你的判断**：X （这题你判对了，但画了问号，说明是不确定的）
    
- **咬文嚼字（必考名词辨析）**：
    
    - **页（Page）**：属于**逻辑地址空间**。我们说“第0页、第1页”，这是在虚拟内存里切分的。
        
    - **页框 / 物理块（Page Frame）**：这才是**物理单位**！是内存条上实实在在的格子。
        
    - **段（Segment）**：是**逻辑单位**（主函数段、数据段）。这点没错。
        
    - **错在哪**：错在前半句。**“页”是逻辑概念，“页框”才是物理概念。**
        

---

### **4. 现代操作系统允许程序装入一部分即可运行。（✓）**

- **你的判断**：X （错）
    
- **你的疑惑**：程序不是要全部进内存才能跑吗？
    
- **核心纠正（虚拟内存的灵魂）**：
    
    - **古代 OS（实模式）**：必须全部装入，否则跑不了。
        
    - **现代 OS（虚拟内存）**：**这就是虚拟内存的定义啊！**
        
        - 你玩一个 50GB 的游戏，你的内存只有 16GB，游戏能跑吗？能！
            
        - 因为系统只把你当前在玩的场景（部分页面）装进内存，剩下的都在硬盘里，等你走过去了再调入（请求调页）。
            

---

### **5. 对文件执行删除操作前须要先打开文件。（×）**

- **你的判断**：✓ （错）
    
- **你的疑惑**：不打开怎么删？
    
- **逻辑链回溯（结合上一章）**：
    
    - 还记得我说的吗？**删除文件 = 修改目录**。
        
    - **Open** 的作用：把 FCB 读入内存，准备**读写文件内容**。
        
    - **Delete (Unlink)** 的作用：把文件名从**目录表**里划掉，把 Inode 链接数减 1。
        
    - **结论**：你根本不需要看文件的内容，你只需要操作**目录**。所以不需要 open 那个文件，而是需要“打开并修改父目录”。
        

---

### **6. 物理文件的组织方式是由外存容量确定的。（×）**

- **你的判断**：✓ （错）
    
- **解析**：
    
    - **看菜吃饭**：物理组织方式（连续、链接、索引）是由**文件的性质**（比如是存经常改的数据库，还是存一次性的录音）和**访问方式**（顺序读还是随机读）决定的。
        
    - 跟硬盘是 1TB 还是 500GB（外存容量）关系不大。容量大你也可能用索引，容量小你也可能用索引。
        

---

### **8. 使用 P、V 操作后，可以防止系统出现死锁。（×）**

- **你的判断**：✓ （错）
    
- **解析**：
    
    - **P/V 是双刃剑**。
        
    - 用得好：解决互斥与同步。
        
    - 用得烂：**直接导致死锁**。
        
    - **例子**：著名的**“哲学家进餐问题”**。如果 5 个哲学家同时拿起左边的筷子（P操作），然后都在等右边的筷子，谁也不撒手，系统就**死锁**了。
        
    - **结论**：P/V 只是工具，它本身不能“防止”死锁，甚至经常是死锁的“元凶”。
        

---

### **10. 为了减少缺页中断率，页面应该小一些。（×）**

- **你的判断**：X （做对了，但我补充一下理由）
    
- **解析**：
    
    - 页面太小 -> 页表就特别长 -> 内存碎片虽然少了，但**局部性变差了**。
        
    - **为什么？** 假设页面只有 1KB，一个函数有 10KB。CPU 执行这个函数，要跨越 10 个页面，可能触发 10 次中断。
        
    - 如果页面有 1MB，这一个函数就在这 1 页里，一次中断就够了。
        
    - **结论**：页面太小反而会增加缺页率。

# 大题
### **1. 从操作系统设计角度，谈谈 PCB 的作用。**

- **你的回答**：
    
    > PCB是进程控制块，描述进程属性、状态。用于OS对进程管理，是调度必要单位。
    
- **严厉诊断**：
    
    - **得分**：3 / 6 分。
        
    - **缺在哪里**：你答的是“PCB 是什么”，题目问的是“为什么要设计 PCB”。你的回答太**功能化**，缺乏**设计哲学**。
        
    - **核心逻辑漏洞**：你没点出 PCB 的**“生死簿”**地位。
        
        - 在没有 PCB 之前，代码只是躺在硬盘上的死尸（程序）。
            
        - **PCB 的本质作用**：它是**程序**变成**进程**的**唯一凭证**。有了 PCB，操作系统才能看见你，才能让你和别人一起跑（并发）。
            
- **满分修正（背这三句话）**：
    
    1. **标志作用（生死簿）**：PCB 是进程存在的**唯一标志**。OS 通过 PCB 感知进程的存在。（没 PCB，OS 就当你是空气）。
        
    2. **转化作用（动静转换）**：PCB 使一个不能独立运行的**程序**（静态），变成一个能独立运行、能并发执行的**进程**（动态）。
        
    3. **管理作用（控制中心）**：PCB 记录了所有调度信息（状态、优先级、寄存器现场），是 OS 进行**进程调度**和**资源分配**的依据。
        
---

### **2. 在虚拟页式存储系统中，为什么要引入缺页中断？**

- **你的回答**：
    
    > 因为虚存让程序员感觉数据在内存，实际可能不在。需要引发中断，把数据调入。
    
- **严厉诊断**：
    
    - **得分**：4 / 6 分。
        
    - **缺在哪里**：你的逻辑完全正确，但表达太“大白话”（比如“体感上”）。而且少了一个关键点：**扩充逻辑内存**。
        
    - **核心逻辑漏洞**：你只说了“缺了就要拿”，没说“这套机制是为了实现什么宏伟目标”。
        
- **满分修正（术语升级）**：
    
    1. **实现请求调页（核心机制）**：当访问的页面不在内存时，硬件无法继续执行指令，必须通过**缺页中断**通知操作系统挂起当前进程，去外存调页。这是**请求页式存储**的核心。
        
    2. **扩充逻辑地址空间（宏伟目标）**：通过“缺页中断 + 调页”的机制，使得用户编程时不受物理内存大小的限制，从而在逻辑上**扩充了内存容量**。
        
    3. **按需加载（效率）**：允许程序只装入部分页面即可运行，不用把整个程序塞进内存。 






### **3. 磁盘访问时间由哪几部分组成？一般怎么计算？**

把读取硬盘想象成**“去图书馆找一本书”**的过程，硬盘是那个圆形的书架。

#### **第一部分：寻道时间 ($T_s$, Seek Time) —— “找书架”**
*   **动作**：磁头（机械臂）在半径方向移动，从当前的磁道（柱面）移动到目标磁道。
*   **这是最慢的一步**：因为是纯机械运动，还要启动、加速、减速。
*   **计算公式**：
    *   $$T_s = m \times n + s$$
    *   $s$：启动磁臂的时间（固有开销）。
    *   $n$：要跨越多少条磁道。
    *   $m$：跨越一条磁道要多久。
*   **优化**：只能靠 **磁盘调度算法**（电梯算法等）来让 $n$ 变小。

#### **第二部分：旋转延迟时间 ($T_r$, Rotational Latency) —— “等书转过来”**
*   **动作**：磁头到了磁道上不动了，等着盘片旋转。目标扇区像旋转木马一样转到磁头底下。
*   **运气成分**：
    *   运气好：刚到就在底下了（0ms）。
    *   运气差：刚转过去，要等一整圈（$1/r$）。
*   **计算公式（取平均值）**：
    *   因为平均要等半圈，所以是 **转一圈时间的一半**。
    *   $$T_r = \frac{1}{2r}$$ （$r$ 是转速，比如 6000转/分 = 100转/秒，那一圈就是 0.01秒）。

#### **第三部分：传输时间 ($T_t$, Transfer Time) —— “把书读出来”**
*   **动作**：磁头磁化感应，把数据读入内存。
*   **计算公式**：
    *   看你要读多少数据，占这一圈的比例是多少。
    *   $$T_t = \frac{b}{rN}$$
    *   $b$：你要读的字节数。
    *   $N$：一圈总共有多少字节。
    *   $r$：转速。
    *   *(其实就是：转一圈的时间 $\times$ (你要读的大小 / 一圈总大小))*

**总结公式（必背，计算题就套这个）：**
$$T_{\text{总}} = T_{\text{寻道}} + T_{\text{平均旋转}} + T_{\text{传输}}$$

---

### **4. 操作系统中的 I/O 管理有哪些常见的优化方法？**

参考答案给了一堆名词，看着很晕。其实它们只有 **三个核心逻辑**。只要记住这三个逻辑，名词随便扯都能对。

#### **逻辑一：缓解 CPU 和 硬盘 的“速度差”**
硬盘太慢，CPU 太快，为了不让 CPU 傻等：

1.  **I/O 缓冲区 (Buffering)**：
    *   **最常用**。在内存里开个小房间。
    *   CPU 把数据扔进房间就走（写缓冲）；或者硬盘先把数据堆在房间里，凑够了 CPU 再来拿（读缓冲）。
2.  **缓存 (Caching)**：
    *   比缓冲更进一步。把**经常用**的数据一直留在内存里（比如文件系统的 Cache）。下次再读直接给，不用动硬盘。
3.  **延迟写 (Write-Back)**：
    *   你要写数据进硬盘？先别急，先写在内存里。说不定等会儿你又要改呢？改完了再一次性写入硬盘。少跑几趟。

#### **逻辑二：让“别人”帮 CPU 干活**
CPU 很贵，用来搬运数据太浪费：

4.  **DMA (直接内存存取)**：
    *   CPU 对 DMA 说：“把这块数据搬到内存”。
    *   DMA 自己去搬，搬完了通知 CPU。期间 CPU 可以去算别的。
5.  **异步 I/O (Asynchronous I/O)**：
    *   程序发起读请求后，**不阻塞**，继续往下跑。等数据到了，系统发个信号通知程序。

#### **逻辑三：优化 硬盘 的“物理动作”**
既然机械运动慢，那就规划好路线：

6.  **磁盘调度算法 (Disk Scheduling)**：
    *   电梯算法（SCAN）。大家都要坐电梯，我顺路带你们，不要一会儿上顶楼一会儿下底楼。
7.  **预读 (Read-Ahead)**：
    *   你读了第 1 页，大概率会读第 2 页。趁着硬盘在转，我顺手把第 2 页也读进内存。

---