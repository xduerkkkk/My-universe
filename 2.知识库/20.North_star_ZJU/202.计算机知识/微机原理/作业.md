# ch4
## 1指令
1. **[] 里只能有 BX, BP, SI, DI**。
    
2. **两边位数要一样** (AX对BX，AL对BL)。
    
3. **两个内存不能对传**。
    
4. **段寄存器 (DS, ES) 不能直接吃数字**。
    
5. **不写 PTR，CPU不知道操作多大内存

6. **MOVS 这种串指令**，后面不要加操作数，它是靠 SI/DI 吃饭的。
    
7. **PUSH/POP 在 8086 里很挑剔**：PUSH 不能压数字，POP 不能弹 CS。
    
8. **段寄存器 (DS, ES...) 是“残疾人”**：不能 MOV 立即数，不能段对段 MOV，不能 XCHG。
    
9. **DIV / MUL 很霸道**：只能写一个操作数（除数/乘数），而且不能是数字，必须是寄存器或内存。
10. **移位 SHL/SHR**：次数超过1，必须用 **CL**。
    
11. **端口 IN/OUT**：端口号要么直接写数字（<256），要么放 **DX**，别的人不行。
    
12. **地址 OFFSET**：地址永远是 **16位** 的，别想放进 AL/BL 里。
    
13. **堆栈 PUSH**：只收 **16位** 寄存器。
恭喜你！这40道题看下来，你已经掌握了 8086 汇编语法的 **80%** 考点了。

以后做这种题，**像安检员一样扫描这几个点**：

1. **扫描 []**：里面必须是 BX, BP, SI, DI 的组合。BX和BP不能共存，SI和DI不能共存。
    
2. **扫描 MOV**：两边位数必须一样（8对8，16对16）；不能两边都是内存；不能两边都是段寄存器。
    
3. **扫描 段寄存器 (DS/ES)**：不能直接给它塞数字（立即数）。
    
4. **扫描 PTR**：如果你只看到 [内存] 和 立即数，没看到寄存器，那就是错的（大小不明）。
    
5. **扫描 特殊指令**：
    
    - **移位**：大于1次用 CL。
        
    - **端口**：大于255用 DX。
        
    - **堆栈**：只能压 16位。

**小结一下指令对的区别套路**：

1. **串指令 (MOVS, STOS, SCAS...)** 最大的特点就是**自带指针移动** (SI/DI ++/--)。
    
2. **LEA 是算地址，MOV 是取值**。
    
3. **SUB 是真减，CMP 是假减（只变标志位）**。
    
4. **BP 默认找 SS，其他通用寄存器默认找 DS**


# 2 寻址
### **（补充）根据条件推测的后续题目**

(题目给出了 20100H 等数据，肯定有对应的指令，以下是标准考法)

#### **(4) 推测指令：MOV AX, [BX]**

- **类型**：**寄存器间接寻址**
    
- **分析**：
    
    - **偏移地址** = BX = 0100H
        
    - **物理地址** = 20000H + 0100H = **20100H**
        
    - 查表得：3412H
        
- **答案**：**AX = 3412H**
    

#### **(5) 推测指令：MOV AX, [BX][SI]**

- **类型**：**基址变址寻址**
    
- **分析**：
    
    - **偏移地址** = BX + SI = 0100H + 0002H = 0102H
        
    - **物理地址** = 20000H + 0102H = **20102H**
        
    - 查表得：7856H
        
- **答案**：**AX = 7856H**
    

#### **(6) 推测指令：MOV AX, 1100H[BX] (或 [BX+1100H])**

- **类型**：**寄存器相对寻址**
    
- **分析**：
    
    - **偏移地址** = BX + 1100H = 0100H + 1100H = 1200H
        
    - **物理地址** = 20000H + 1200H = **21200H**
        
    - 查表得：4C2AH
        
- **答案**：**AX = 4C2AH**
    

#### **(7) 推测指令：MOV AX, 1100H[BX][SI]**

- **类型**：**相对基址变址寻址**（全家桶）
    
- **分析**：
    
    - **偏移地址** = BX + SI + 1100H = 0100H + 0002H + 1100H = 1202H
        
    - **物理地址** = 20000H + 1202H = **21202H**
        
    - 查表得：65B7H
        
- **答案**：**AX = 65B7H**
    

---

### **做题心得总结**

这道题的核心就一个公式：  
**物理地址 = 20000H (DS基址) + []里算出来的数**


# 3循环
1. **搜索循环模版**（必背）：
    
    - MOV CX, 长度
        
    - MOV SI, -1 (或者0，看逻辑)
        
    - INC SI
        
    - CMP ...
        
    - LOOPNZ NEXT (没找到继续找)
        
    - JNZ NOT_FOUND (循环结束如果还是不相等，就是没找到)
        
    - FOUND: (找到了)
        
2. **逻辑运算口诀**：
    
    - **AND (与)**：用来**清零**（想清零哪一位，就跟0与）。
        
    - **OR (或)**：用来**置1**（想把哪一位置1，就跟1或）。
        
    - **XOR (异或)**：用来**取反**（想把哪一位取反，就跟1异或；跟0异或保持不变）。**自己异或自己 = 0**（清零最快方法）。

# 4代码
在 8086（16位机）中，寄存器最大只有 16 位。要处理 32 位数，必须把它拆成 **高16位（DX）** 和 **低16位（AX）** 两个部分来协同工作。

### **核心思路**

1. **保存“尾巴”**：  
    题目要求把“移出的低 3 位”保存在 CL 中。这 3 位原本在 AX 的最右边。移位之前，先把它们备份出来。
    
2. **32位右移怎么做？（接力跑）**
    
    - 想象 DX 和 AX 是两根首尾相接的水管：[ DX ] -> [ AX ] -> 悬崖。
        
    - **第一步**：**高位（DX）** 向右移 1 位。最右边的那一位会被挤出来，掉进 **CF（进位标志位）** 里。
        
        - 指令：SHR DX, 1 （逻辑右移，高位补0）。
            
    - **第二步**：**低位（AX）** 向右移 1 位。重点来了，**它必须去接住刚才从 DX 掉进 CF 里的那一位**，把它放到自己的最高位。
        
        - 指令：RCR AX, 1 （带进位循环右移）。
            
    - **重复 3 次**，就完成了 32 位数的右移。
        

---

### **代码实现**

codeAssembly

```
; 1. 先保存要被移走的低3位
MOV CL, AL      ; 把 AL (AX的低8位) 复制给 CL
AND CL, 07H     ; 07H = 0000 0111B，做“与”运算，只保留最后3位，其他清零。
                ; 现在 CL 里存的就是未来的“移出位”了。

; 2. 开始 32位 移位操作
; 我们需要循环 3 次。
; 注意：不能用 LOOP 指令或 CX 计数，因为 CL 已经被占用了！
; 我们用 SI 或 BL 当计数器，这里用 BL。

MOV BL, 3       ; 设置循环次数为 3

L1:             ; 循环标号
    SHR DX, 1   ; 【关键】高位逻辑右移1位。最低位进入 CF，最高位补0。
    RCR AX, 1   ; 【关键】低位带进位右移1位。CF(原DX最低位)进入AX最高位。
    
    DEC BL      ; 计数器减 1
    JNZ L1      ; 如果 BL 不为 0，跳回 L1 继续移位
```

---

### **避坑指南（考试重点）**

1. **为什么不用 LOOP 指令？**
    
    - LOOP 指令强制使用 CX 寄存器做减法计数。
        
    - 但是题目要求结果存 CL。CX = CH:CL。如果你用 LOOP，它会自动修改 CX 的值，这就把你保存在 CL 里的结果给**破坏**了。
        
    - **对策**：用其他寄存器（如 BL, SI, DI）手动计数 (DEC + JNZ)。
        
2. **为什么要用 RCR？**
    
    - SHR 是补 0，RCR 是补 CF。
        
    - AX 的最高位，必须是 DX 移出来的那个位（也就是 CF），所以必须用 **带进位** 的移位指令。
        
3. **DEC 指令不影响 CF**
    
    - 在循环中，DEC BL 会改变 ZF 标志位（用于判断是否结束），但**不会改变 CF**。
        
    - 所以，SHR 产生的 CF 可以安全地跨过 DEC 指令，保留给下一轮的 RCR 使用。这是 8086 指令集设计的精妙之处。