# **【Ch2 核心浓缩：8086 寄存器表】(背下来，必考)**

1. **通用寄存器 (存数据的)**：
    
    - AX (Accumulator)：**累加器**。乘除法指令强制用它，I/O指令也爱用它。算术运算首选。
        
    - BX (Base)：**基址寄存器**。**重点！** 只有它（和BP/SI/DI）能用来放内存地址（写在[]里）。
        
    - CX (Count)：**计数器**。**重点！** LOOP指令自动减它，移位指令用它记次数。
        
    - DX (Data)：数据寄存器。乘除法辅助AX，或者存I/O端口号。
        
    - 注：它们都可以拆成高8位(AH, BH...)和低8位(AL, BL...)使用。
        
2. **指针变址寄存器 (存偏移地址的)**：
    
    - SI / DI：数组复制时的源/目的索引。
        
    - SP (Stack Pointer)：**栈顶指针**。指向堆栈当前最上面的数据（自动变）。
        
    - BP (Base Pointer)：**基址指针**。通常用来访问栈里的局部变量。
        
3. **段寄存器 (存段基址的，408重点)**：
    
    - CS (Code)：代码段。
        
    - DS (Data)：数据段（你的全局变量都在这）。
        
    - SS (Stack)：堆栈段。
        
    - ES (Extra)：附加段（串操作用）。
        
4. **控制寄存器**：
    
    - IP (Instruction Pointer)：**PC**（程序计数器）。指向下一条要执行的指令。
        
    - FLAGS (PSW)：状态字。存 ZF(零标志), CF(进位), OF(溢出) 等。
        

---

困惑：
AX BX CX DX  为啥都有个X？x是啥意思
 **"eXtended"（扩展）**
 
 
寻址到底啥意思？
**找数据的方法**

MOV是啥？赋值吗？

MOV AX，2000H  2000H是地址，是存哪的地址，RAM芯片？ 然后AX是啥，不应该是累加器的意思吧？  这个要访问内存？内存就是R 吧     AM嘛？ 
AX就是累加器，2000H是数字，也是地址，这就是 立即数寻址 
# ch4


## 寻址方式
- 立即数

- 寄存器寻址 MOV AX BX

- 直接寻址 MOV AX，`[2000H]`
MOV AX, [2000H]。带了**中括号 []**，就是去**内存**取数！偏移地址是2000H。
    
- **考研计算公式**：**物理地址 = 段地址(DS) × 16 + 偏移地址**。
	
- (例：DS=3000H, [2000H]。物理地址 = 30000H + 2000H = 32000H)。
啥意思？

### **. 关于地址计算：DS × 16 + 偏移地址 是啥意思？**

**情景还原**：  
8086 CPU 是一台 **16位** 的机器，它的寄存器（BX, SI 等）只有 16位，最多只能表示 0 ~ 65535 (64KB) 的数字。  
**但是**，它的地址总线有 **20根**（20位），能访问 **1MB** 的内存（00000H ~ FFFFFH）。

**问题来了**：**怎么用 16位 的寄存器，去拼凑出一个 20位 的物理地址呢？**  
这就好比：你的房间号是 5位数（20位），但你的手里的卡片只能写 4位数（16位）。怎么办？

**解决方案（分段管理）**：需要两张卡片。

1. **段地址 (Segment)**：代表“小区号”。存放在 DS (数据段) 或 CS (代码段) 里。
    
2. **偏移地址 (Offset)**：代表“小区内的楼号”。存放在 BX 或 IP 里。
    

**计算规则**：**物理地址 = 段地址 × 16 + 偏移地址**

- **×16 是什么鬼？** 在十六进制里，乘以16等于**左移一位（后面补个0）**。
    
- **例子**：
    
    - DS = 3000H （小区号是 3000）
        
    - 偏移 = 2000H （楼号是 2000）
        
    - CPU内部计算器：先把 3000H 变成 30000H (左移一位，即乘以16)，然后加上 2000H。
        
    - **结果**：32000H。这就是最终发到地址总线上的 **20位物理地址**。
        

> **结论**：这个公式就是 Intel 为了在16位CPU上强行访问1MB内存搞出来的“拼凑大法”。



- 寄存器间接寻址 MOV AX，`[BX]`
- 相对寻址



- 两个内存单元不能直接传送 (MOV [BX], [SI] 是**错**的)。
    
- 两个段寄存器不能直接传送 (MOV DS, ES 是**错**的，必须用AX中转)。
    
- 数据宽度必须一致 (MOV AL, BX 是**错**的，一个是8位一个是16位)。

**(堆栈 PUSH/POP)**：
- **规则**：堆栈只能操作**16位**（字），不能压8位数据。 为什么？
    
- **执行过程**：PUSH 是先 SP-2 再存；POP 是先取再 SP+2   数据先从高位存起吗？我不清楚细节  反正我看相对数字大的地址是“栈底”
#### **Q1: 为什么只能操作 16位？**

**原因**：这是 8086 的硬件设计规定的。堆栈主要用来保存从寄存器里拿出来的数据（比如 AX, BX），或者保存函数调用时的返回地址（IP）。因为 8086 的寄存器和地址都是 **16位** 的，所以设计者规定：**堆栈操作必须一次进出 2个字节（1个字），不允许只进一半。** 这样效率最高，也能保持内存对齐。

#### **Q2: SP-2 还是 SP+2？栈底在哪？**

**情景**：想象你在**从天花板往下**盖一座楼。

- **栈底**：是**高地址**（比如 1000H），是最初的位置，不动。
    
- **栈顶 (SP)**：是**低地址**，随着数据进来，SP 往**低**处跑。
    

**动作解析**：

- **PUSH (入栈)**：
    
    1. **SP = SP - 2**：你也看出来了，栈顶SP要往上浮（往低地址走），腾出空间。
        
    2. **存数据**：把 16位数据写进去。
        
    3. **高低位顺序**：**小端模式 (Little Endian)**。低8位在低地址，高8位在高地址。
        
- **POP (出栈)**：
    
    1. **取数据**：先把数据读出来。
        
    2. **SP = SP + 2**：SP 往下沉（往高地址走），释放空间。





PSW中的6个状态标志位：CF、AF、 OF、SF、ZF和PF是啥？
 CMP A, B 实际上是做 A - B，但**不保存结果**，只改变标志位。它专门给 JMP 指令用的。  什么意思？ 
### **PSW 标志位：6个红绿灯**

这些标志位是 ALU（算术逻辑单元）算完一次后，自动留下的“案发现场痕迹”。

- **CF (Carry Flag) 进位标志**：**无符号数**溢出了。（像汽车里程表，9999 + 1 = 0000，进位了）。
    
- **ZF (Zero Flag) 零标志**：结果是不是 **0**。是0则ZF=1。（这是判断相等的关键）。
    
- **SF (Sign Flag) 符号标志**：结果是正还是负（看最高位是0还是1）。
    
- **OF (Overflow Flag) 溢出标志**：**有符号数**溢出了。（正+正=负，或者 负+负=正，脑子炸了）。
    
- **PF (Parity Flag) 奇偶标志**：结果里有偶数个1。（现在很少用了，不用管）。
    
- **AF (Auxiliary Flag) 辅助进位**：低4位向高4位的进位。（做BCD码运算用的，也不用深究）。
    

> **重点记 CF, ZF, SF, OF。**




- **坑点**：DIV BL 意思是 AX / BL。商在 AL，余数在 AH  为啥如此默认？
