---
share_link: https://share.note.sx/qti130et#Yz5VpQSXjtipcSrdTNsWOq92B5Z28kOOUpJYWUWbLR4
share_updated: 2025-09-23T14:12:57+08:00
---
## 进程与线程的概念
首先，线程是进程的执行单位，是最小单位，我们平常操作系统调度就用的线程。所以我们把线程想象成一个“工人”，进程想象为一个项目组。
所以我们可以进一步说：
**进程是资源分配的单位，线程是CPU调度的单位**

大家可以看到，一个复杂的exe文件的运行，就是所谓“进程”。他们占的内存，cpu的利用程度，就是公司批给项目组（进程）的资源。一个软件那么多要实现的功能，可知有许多线程包含在进程里了。
![[一文搞懂线程、进程、并发、并行、同步、异步-1755499466989.jpeg]]
我们公司执行任务都是交给项目组嘛，公司给项目组批经费、配办公室、给服务器账号。这些就是**资源**。
项目黄了，这些资源会被整个收回。
但是计算机科学的世界里，**极其**在意对工人的安排。假如说os的调度器是项目经理，他会及其在意每一个打工人的安排，他会直接调度打工人，更加细化！
所以我们有这样的思想，虽然说是给你整个项目组资源，但我公司对员工要求特别高，要求精细到每个员工干的什么活，什么时候干！！
所以平常说的最多的应该是**线程**。
## 同步与异步
一个核心：
**一个cpu核，一个时间下，只能调用一个线程**。
他可以从始至终调用一个线程，完成任务。线程老老实实完成手底下的任务。
这个任务中如果出现特殊情况，需要读写硬盘， 结果发现，哎呀硬盘干其他事呢，我就等着吧。
于是此线程原地等待硬盘，不在进行其他操作，这叫**同步阻塞**。
那如果，线程说不等待硬盘，给硬盘说"你如果好了叫我，我去干不需要你的事情了“，这就叫**异步**！

## 并发与并行
项目经理（单核CPU）手下有好几个任务需要推进，但他一次只能指挥一个工人干活。怎么办呢？
如果他一开始呼叫多个线程，因为有很多活啊！但一个时间下，只能调用一个线程呀。
那么他会快速切换线程完成各自的任务， 一个线程干0.01s 下一个0.01s立刻叫另一个线程干一下他的活 下一个... 这样，用户体感上，就好像他们在同时干活。
但其实是**交替干活**，一个时间下只有一个线程干活，所以真实情况一定比同时干活慢。 这叫**并发**。
- 由于线程切换本身也需要时间（我们称之为“上下文切换开销”），**如果所有任务都是纯计算型的，那么并发执行的总耗时确实会比顺序执行更长**。但它的魔力在于，当一个任务需要等待（比如等硬盘响应）时，CPU可以立刻切换去执行其他任务，从而极大地提高了CPU的利用率，使得总体的完成时间大大缩短
如果我们有多核cpu，那我们可以真正做到一个核调用一个线程，多个线程同时开始，一个时间下有多个线程干自己的活，用户不进是体感上同时，实际上**同一时刻任务也是真真正正地一起执行**，这叫**并行**。


## 梳理

| 概念     | 核心思想                  | 硬件要求 | 比喻               |
| ------ | --------------------- | ---- | ---------------- |
| **同步** | 发出调用，原地等待结果，期间不做别的事   | 无    | 在复印机前死等          |
| **异步** | 发出调用，不直接等结果，去做别的事     | 无    | 告诉同事复印好了叫我       |
| **并发** | 多个任务在一段时间内交替执行，宏观上像同时 | 单核即可 | 1个项目经理快速切换指挥多个工人 |
| **并行** | 多个任务在同一时刻一起执行         | 必须多核 | 多个项目经理同时指挥多个工人   |
  
所以同步和异步只是说线程“**在等结果时，所处的状态**”，与并行并发的概念本身没有任何关系，并行并发只关心**整体的推进**，是多个线程一起啊还是交替多个线程啊，有的关系只是，如果做到每个线程都是异步状态，并发就很容易实现，因为并发需要不断切换、调用线程，你要有个线程堵塞了那不就完了。  

## Python中的 asyncio
笔者最开始接触这些概念，就是来源于python的asyncio库，于是这里也介绍一下，这个库如何用到了这些概念。
asyncio 的核心是**单线程并发**，我们刚才提到并发的举例是**多线程并发**，可以再回过头看一下多线程并发的举例，然后思考单线程并发是干嘛。
单线程并发就是一个线程，即一个工人，去交替执行任务，他其实认领了很多种任务。
刚才的多线程并发，每个工人手头只认领了一种任务。
然后这个线程也是很聪明，掌握了异步工作的能力（在asyncio里叫**协程**） 当事件循环运行到一个标记为 await 的操作时（通常是耗时的 I/O 操作），它不会傻等。相反，它会将这个任务挂起，然后立即去执行其他已经准备好的任务。当之前挂起的 I/O 操作完成后，事件循环会收到通知，并在下一个合适的时机切换回去继续执行该任务。
这个过程由asyncio的**事件循环**来统一调度。它就像一个手速超快的调度员，确保这唯一的工人永远在做“当前能做”的事情，绝不把时间浪费在“同步等待”上。这就是为什么asyncio在处理高并发的网络I/O等场景时，性能极高的原因。