平常这种 for item in items 很迭代器吧，每次都调用items的一个，并按顺序往下走
其实for循环在背后，调用了__iter__()和__next__()
啊 iter(),传入一个可迭代对象，就获取了迭代器。next是迭代器的方法！

生成器是迭代器的一种
等等，刚才我们讲的迭代器是哪种？？
是iter（可迭代对象），是【1，2，3】这样的
一眼能看出结构的，对吧？
看到了这个可迭代对象，我就能想象出从第一个开始迭代，会输出1，下一次next'，会2
可以视作由可迭代对象生成的迭代器，把数据早早都准备好了，随时等你next。你来next，它就放出去

而生成器有点懒
他不会一口气把数据准备好
他等你叫他
我觉得这个示例不太好，看起来还是一口气把数据准备好的样子，但我要先放在这，给大家介绍一下
当发现这个函数里面有”yield“时，说明这个函数就是个”懒货“，也就是函数是”生成器“
print simple_generator() 会得到
<generator object simple_generator at 0x000001F5E6B8D7B0>
不是function了
我们如何才能让他动起来？
用next（simple_generator() ） 就会催使函数生成，预设好的”1“
```python
def simple_generator():
    yield 1
    yield 2
    yield 3

```
来个更好的例子
 返回斐波那契数列前 N 项
 很经典的动态规划的题目

```python
def fibonacci_dp(n):
    if n <= 0:
        return []
    
    dp = [0] * n
    dp[0] = 0
    if n > 1:
        dp[1] = 1
    
    for i in range(2, n):
        dp[i] = dp[i - 1] + dp[i - 2]
    
    return dp

```

```python
def fibonacci_list(n):
    result = []
    a, b = 0, 1
    for _ in range(n):
        result.append(a)
        a, b = b, a + b
    return result

# 使用示例
print(fibonacci_list(10))  # 输出前10项

```


```python
def fibonacci(n):
    a, b = 0, 1
    count = 0
    while count < n:
        yield a
        a, b = b, a + b
        count += 1

# 测试代码
for num in fibonacci(10):
    print(num)

```
