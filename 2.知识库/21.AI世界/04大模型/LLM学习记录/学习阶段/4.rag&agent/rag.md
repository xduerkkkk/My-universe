rag的基本定义：xxxx



先介绍方法，从增强prompt和增强检索两方面，分别介绍如何rag

最后，分析，综合两方面的方法，得到一个流程
# 增强prompt

在用户提问环节，两个方法
# *Multi  Query*  ：
构建generate_queries的langchain链，功能为基于用户的问题，完善词汇，改变句型等，生成多个问题。
实现通过prompt增加，来增强问题检索‘

![[rag-1750825361916.jpeg]]


## *Query Decomposition*
将复合问题拆解为多个子问题，逐步检索+分步解答（类似“分治法”）
用户问题：“特斯拉2024年Q1的营收和比亚迪对比如何？”  
→ 模型拆解：  
（1）检索特斯拉2024 Q1营收数据  
（2）检索比亚迪同期营收数据  
（3）对比分析差异

```python
# Chain
generate_queries_decomposition = ( prompt_decomposition | llm | StrOutputParser() | (lambda x: x.split("\n")))
```
借助langchain链，构建能拆解问题的模型


在该方法下，针对子问题的处理，有
​**​“递归式分解”（Answer Recursively）​**​ 和 ​**​“独立式分解”（Answer Individually）​**​ 两种不同的子问题处理逻辑。
以下是对二者的核心区别解析：

---

### ​**1. 递归式分解（Answer Recursively）​**​

​**核心逻辑**​：子问题之间**存在依赖关系**，需按顺序分步解决，前一个子问题的答案作为后一个子问题的输入。  
​**适用场景**​：多跳推理（Multi-hop QA）、因果链分析、分步骤决策类问题。  
​**技术特点**​：

- ​**链式调用**​：子问题按逻辑顺序执行，形成“问题链”（Question Chaining）
- ​**上下文传递**​：前序答案作为后序问题的检索依据或生成背景；
- ​**动态调整**​：后续检索可能基于前序结果调整查询逻辑。

​**案例说明**​：

> ​**用户问题**​：“马斯克收购 Twitter 后，对特斯拉股价有何影响？”  
> ​**递归分解流程**​：
> 
> 1. 子问题1：_“马斯克何时完成 Twitter 收购？”_ → 答案：2023年10月
> 2. 子问题2：_“2023年10月后特斯拉股价的波动情况？”_（依赖子问题1的时间点）
> 3. 整合答案：基于时间点检索股价数据，分析收购事件的影响

![[rag-1750840284749.jpeg]]
---

### ​**2. 独立式分解（Answer Individually）​**​

​**核心逻辑**​：子问题**相互独立**，可并行检索与回答，最后整合结果。  
​**适用场景**​：多维度事实查询、多实体对比、无逻辑依赖的复合问题。  
​**技术特点**​：

- ​**并行处理**​：子问题同时检索，提升响应速度
- ​**结果聚合**​：答案通过拼接、投票（Voting）或重排序（Reranking）整合；
- ​**容错性高**​：单个子问题错误不影响其他部分。

​**案例说明**​：

> ​**用户问题**​：“对比 ChatGPT-4 和 Claude 3 的代码能力与多模态支持。”  
> ​**独立分解流程**​：
> 
> - 子问题1：_“ChatGPT-4 的代码生成能力如何？”_
> - 子问题2：_“Claude 3 的代码生成能力如何？”_
> - 子问题3：_“ChatGPT-4 的多模态支持能力？”_
> - 子问题4：_“Claude 3 的多模态支持能力？”_  
>     → 并行检索后，按维度（代码/多模态）对比生成答案
  

​**优化策略**​：对独立子问题使用混合检索（向量+关键词），提升召回率

![[rag-1750840320396.jpeg]]


## Stepback

抽象化问题，
以具体问题为例，展示Step-Back的标准化流程
#### 案例：_“若理想气体温度增2倍、体积增1倍，压力P如何变化？”_

1. ​**Step 1: Abstraction（抽象层提问）​**​
    
    - ​**Prompt**​：  
        _“解决此任务涉及哪些物理原理和概念？”_
    - ​**模型输出**​：  
        _“理想气体状态方程（PV=nRT）”_
2. ​**Step 2: Reasoning（原理指导推理）​**​
    - ​**Prompt**​：  
        _“根据PV=nRT，推导温度与体积变化对压力的影响。_

![[rag-1750840871180.jpeg]]

# 增强检索
## *Rag Fusion*
对检索的结果排序
当有多个问题，多个回答时。
我们对所有回答排序
筛选最优回答
多路查询扩展 + 重排序
![[rag-1750840802966.jpeg]]
## HyDE
**核心原理**​：​**让LLM生成“理想答案”作为检索依据**，而非直接使用用户查询
1. ​**假设生成**​：输入问题“区块链如何改进供应链？”，LLM输出假设文本：“区块链的不可篡改性和溯源能力可提升物流透明度...”；
2. ​**嵌入检索**​：将假设文本向量化，检索真实文档；
3. ​**生成答案**​：结合检索结果生成最终响应

![[rag-1750840891161.jpeg]]

# 综合所有流程，rag思维导图

![[rag-1748001729274.jpeg]]

# 选择方法
Multi Query是适用性最广泛的一个方法，因为原理最简单，就是把一个问题变成多个同级问题。
所以Multi Query对prompt的增强后，还可以继续运用Decomposition，对每个问题都进行拆解子问题。
stepback可以用在Multi Query前？？ 
最终，prompt的升级后，进行检索后的ragfusion，排序，以输出最优回答

最终选择，
### **StepBack → Decomposition → Multi-Query → RAG-Fusion**

`用户问题` → ​**StepBack抽象化**​ → ​**Decomposition拆解**​ → ​**Multi-Query扩展**​ → ​**混合检索**​ → ​**RAG-Fusion融合排序**​ → ​**生成答案**

#### **StepBack前置：构建认知框架​**​

- ​**作用**​：将具体问题提炼为抽象原理（如“特斯拉股价影响因素” → “企业收购对股价的通用分析框架”），避免陷入细节陷阱
   
- 抽象问题能更准确定义后续拆解方向（如识别需检索“收购时间”“股价波动”等子维度）

- ​**跳过场景**​：简单事实查询（如“PDF第几页提到定价策略？”）可直接进入Decomposition。

#### ​**2. Decomposition：问题拆解（递归式+独立式并行）​**​

- ​**作用**​：将抽象问题拆解为可检索的子问题

- ​**关键策略**​：
    - ​**递归式拆解**​：用于逻辑链问题（如“收购时间→股价数据→行业对比”）
        
    - ​**独立式拆解**​：用于多维度问题（如“产品参数对比”拆为A参数、B参数独立查询）

- ​**优势**​：解决多跳推理问题，且独立子问题可并行检索提速

#### ​**3. Multi-Query：同级查询扩展**​

- ​**作用**​：为每个子问题生成3-5个语义变体（如“股价影响因素” → “收购后股价变化”“行业竞争格局影响”）

- ​**位置理由**​：
    - 在Decomposition**之后**执行：确保每个子问题充分覆盖表述多样性（如专业术语vs口语表达）

    - 实验数据：Multi-Query使长尾问题召回率提升18%
#### ​**4. RAG-Fusion：多路检索结果融合**​

- ​**作用**​：整合Multi-Query的多路检索结果，通过**RRF算法**加权排序