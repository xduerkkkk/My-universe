> “如何利用词向量进行无监督句子相似度计算任务？”

**翻译**:  
“现在，我**没有**任何标注好的句子对（比如('天气真好', '今天晴空万里') -> 1 (相似)；('天气真好', '我爱吃苹果') -> 0 (不相似))。我只有一堆**预训练好的词向量**（比如Word2Vec或BERT模型），以及两个新的句子A和B。

请你设计一个**不需要额外训练**的、纯粹基于计算的方法，来判断句子A和句子B在**语义上有多相似**。”


首先我们直觉能想到的最简单的，就是一个句子的含义，大致是所有词向量的加和平均
然后两个句子余弦相似度 看是否相似。
但其中有的问题，是语义漂移，忽略词序

稍微改进是**TF-IDF权重**  像‘a’, ‘the’这种不重要的停用词，它们的权重会很低；而像‘transformer’, ‘attention’这种核心词，它们的权重会很高，从而在最终的句子向量中占据主导地位。 这在短句子挺不错 仍然有语义漂移


使用bert是最ok的了，
不过bert输出的句子向量是 n，d  我们只需要一个向量所以一般池化
取cls向量 或者平均


```python
假设我们已经通过池化得到了两个句子的向量
vec_A = torch.tensor([1.0, 2.0, 3.0])
vec_B = torch.tensor([2.0, 4.0, 6.0]) # 和A同向，但长度是2倍
vec_C = torch.tensor([-1.0, -2.0, -3.0]) # 和A反向
vec_D = torch.tensor([3.0, -1.0, 0.0]) # 和A方向不同


dot_product = torch.dot(vec_A, vec_B)
norm_A = torch.linalg.norm(vec_A)
norm_B = torch.linalg.norm(vec_B)
similarity_AB_manual = dot_product / (norm_A * norm_B)

print(f"手动计算 A和B 的相似度: {similarity_AB_manual.item()}") # 结果会非常接近 1.0
```

# 如何使用bert构建有聚类性质的句子向量？

但这道题里说的“有聚类性质的句子向量”，指的是S-BERT这个模型**本身**所产出的**整个向量空间的性质**。即，这个模型本身就是一个能生成“适合聚类的、语义结构良好”的句子向量的工具